ID,RawPractice,Type,Theme,Component,Sub-theme,Sub-sub-theme,GuidelineID,NewGuidelineID,OccurrencyGuideline,WorkingGuidelines
261,[MVVM] We should make sure that every action of the user goes through the ViewModel and that any possible logic of the View is moved in the ViewModel.,G,MVVM,"V,VM",ALWMOD,,"MVVM1,MVVM2","MVVM5, MVVM1","2,5","Views should always know about changes after ViewModels, no matter how trivial an operation may be.. Views are passive and should always expose only their state. Components should exclusively expose their state (i.e., events plus data), instead of \tocheck{state} and data separately."
226,"[On MVVM] The importance of a well designed view entity. One common mistake is to pass the view an object that hasn’t been designed for it, usually because we don’t want to create another object that is specific for the view, so we rather just pass the one that comes from our data or domain layer. This should be avoided because it means that the view needs to do some final transformations to be able to consume it, leaving code that contains untested logic. In our experience, the most critical step working in the presentation layer is the design of the view entities. Creating these POJOs is in a way the main goal of the presentation layer and defines how readable, understandable and testable the whole layer is. [Nice quote on MVVM] Take your time designing the view entities. You don’t want to deal with a poorly designed one and it is painful to change them when the implementation of the presentation layer is advanced.",B,"MVVM,CLEAN","V,VM","PV,CES",,"MVVM2, MVVM3",MVVM1,"5, 3","Components should exclusively expose their state (i.e., events plus data), instead of \tocheck{state} and data separately."
227,"Expose states and not events: expose one stream per view that emits states instead of events. Both the position and the data set should be wrapped up together so the ViewPager never receives one without the other. This is true for any view with intradependent state. You would never expose two separate streams for a TextView, one that sets the text and another one that emits the position of the letter that should be highlighted in bold, but for some reason it’s much easier to make this mistake with a ViewPager or lists. [MVVM+RxJava]",M,MVVM,V,"PV,CES",,"MVVM2,MVVM3",MVVM1,"5, 3","Components should exclusively expose their state (i.e., events plus data), instead of \tocheck{state} and data separately."
223,"The view entity should be designed to represent as close as possible the state of one specific view. Some time ago I wrote a blog post about how to design this view entities safely, things that need to be taken into account when dealing with RxJava + MVVM.",G,MVVM,"M,VM,V",,,MVVM2,MVVM1,5,"Components should exclusively expose their state (i.e., events plus data), instead of \tocheck{state} and data separately."
260,"[MVVM] The ViewModel should expose states for the View, rather than just events.",G,MVVM,VM,CES,,MVVM3,MVVM1,5,"Components should exclusively expose their state (i.e., events plus data), instead of \tocheck{state} and data separately."
89,"Using this model, the database serves as the single source of truth, and other parts of the app access it using our UserRepository. Regardless of whether you use a disk cache, we recommend that your repository designate a data source as the single source of truth for the rest of your app.",G,MVVM,M,SST,,MVVM8,MVVM2,4,The app should possess a single source of truth of data.
201,What if we only have one single source of truth for state passed from bottom (business logic) to the top (the View). [It would be a very good thing],G,MVVM,"M,V",SST,,MVVM8,MVVM2,4,The app should possess a single source of truth of data.
200,"A Presenter (or ViewModel) has arbitrarily many inputs (the View triggers an action handled by Presenter) which is ok, but a Presenter also has many outputs (or output channels like view.showLoading() or view.showError() in MVP or ViewModel is offering multiple Observables) which eventually leads to conflicting states of View, Presenter and business logic especially when working with multiple threads.",B,MVVM,VM,SST,,MVVM8,MVVM2,4,The app should possess a single source of truth of data.
88,"By relying on our current implementation in this situation, we need to fetch the data again from the network. This refetching process isn't just a bad user experience; it's also wasteful because it consumes valuable mobile data. You could fix this issue by caching the web requests, but that creates a key new problem: What happens if the same user data shows up from another type of request, such as fetching a list of friends? The app would show inconsistent data, which is confusing at best. The proper way to handle this situation is to use a persistent model. This is where the Room persistence library comes to the rescue.",M,MVVM,M,"LDBN,SST",,"MVVM7, MVVM8","Gen8, MVVM2","2, 4",local DB first then network. The app should possess a single source of truth of data.
108,The view model isolates the view from the model classes and allows the model to evolve independently of the view.,G,MVVM,M,IM,,MVVM13,MVVM3,3,Models should be evolvable/testable independently from the rest of the app (\eg by adopting the  inversion of control principle)
169,"If the data binding logic is too complex, application debug will be a little harder.",B,MVVM,M,IM,,MVVM13,MVVM3,3,Models should be evolvable/testable independently from the rest of the app (\eg by adopting the  inversion of control principle)
262,"[MVVM] DataModel: The use of inversion of control pattern, heavily applied in our code, and the lack of any Android classes, facilitate the implementation of unit tests of the DataModel.",G,MVVM,M,IM,,MVVM13,MVVM3,3,Models should be evolvable/testable independently from the rest of the app (\eg by adopting the  inversion of control principle)
136,"Never pass context into ViewModel instances. Do not store Activity, Fragment, or View instances or their Context in the ViewModel. For example, an Activity can be destroyed and created many times during the lifecycle of a ViewModel, such as when the device is rotated. If you store a reference to the Activity in the ViewModel, you end up with references that point to the destroyed Activity. This is a memory leak. If you need the application context, use AndroidViewModel instead of ViewModel.",B,MVVM,VM,VMNV,,MVVM12,MVVM4,3,"ViewModel should not refer to View-specific components (e.g., Activities), it may use for example LiveData provided by Jetpack so that activities can simply observe its changes."
135,"When you pass data through the layers of your app architecture from a Room database to your UI, that data has to be LiveData in all layers: All the data that Room returns to the Repository, and the Repository then passes to the ViewModel, must be LiveData. You can then create an observer in the activity that observes the data in the ViewModel.",,MVVM,,VMNV,,MVVM12,MVVM4,3,"ViewModel should not refer to View-specific components (e.g., Activities), it may use for example LiveData provided by Jetpack so that activities can simply observe its changes."
258,"[MVVM] The consumer of the data should know about the producer, but the producer — the ViewModel — doesn’t know, and doesn’t care, who consumes the data.",G,MVVM,"M,VM",DCKP,,MVVM4,MVVM4,3,"Data Consumer knows producers, not the other way around. "
228,"[MVVM+RxJava] Everything goes through the view model: the view model transforms the data into something that is easy to use in the Views or any other consumer, this means the view should know about the changes always after the view model. So basically, it doesn’t matter how trivial or easy an operation is, everything should go through the view model, this way other stuff that is based on the view model’s state can happen reliably. The view should know about the changes always after the view model.",G,MVVM,"M,VM,V",ALWMOD,,MVVM1,MVVM5,2,"Views should always know about changes after ViewModels, no matter how trivial an operation may be."
259,"[MVVM] Our strong emphasis on the single responsibility principle leads to creating a DataModel for every feature in the app. For example, we have an ArticleDataModel that composes its output from the API service and database layer. This DataModel handles the business logic ensuring that the latest news from the database is retrieved, by applying an age filter.",G,MVVM,M,OMOF,,MVVM10,MVVM6,2,One data model for each feature of the app.
170,"Do not make reference to a database or an API directly in the ViewModel. Instead, create Repository for each VM — thus the code will be cleaner and less bulky.",M,MVVM,"M,VM",OMOF,,MVVM10,MVVM6,2,One data model for each feature of the app.
225,"[On MVVM] The View Model should not do any of the things the components above can do. The View Model should coordinate the process of creating view entities and put all the pieces together. After doing this we noticed several benefits: the most obvious one was that the view models have a much smaller size, everything was easier to test since each class has a more specific and narrow responsibility, it is more clear what are the inputs/outputs and what is expected from each class. Of course this also makes the whole presentation layer more understandable and readable.",G,"MVVM,CLEAN",VM,KMSS,,MVVM6,MVVM7,2,"Keep ViewModels as simple as possible (when needed, use transfer responsibility to other layers - like Models - or other components such as data transformers, components factories, etc.)."
224,"In MVVM pattern, the ViewModel is the component that interacts with the views, this leads to often have big view models, especially when the screen is complex. We tried to simplify our view models delegating some responsibilities to other components: - Mappers and transformers: They transform the objects coming from the domain layer to view entities. - Providers: Sometimes we need something from the framework to build our view entity, for instance, we might need a specific string. We create the StringProvider to abstract the access to this resource. - Utilities: There is not much to say here, these are the classical utility classes that contain helper functions.",M,"MVVM,CLEAN","VM, C",KMSS,,MVVM6,MVVM7,2,"Keep ViewModels as simple as possible (when needed, use transfer responsibility to other layers - like Models - or other components such as data transformers, components factories, etc.)."
263,[MVVM] we are creating model objects to hold the state of the data. This also allows a higher degree of testability and control of the data that is emitted by the ViewModel.,G,MVVM,M,SDIM,,MVVM11,MVVM8,1,State defined in the models only.
219,The plan is to put in the store the objects that are going to be consumed by the layers on top. This layer will build use cases out of these objects so let’s make sure the data we store is in good conditions. [Reactive Clean Architecture],G,"MVVM,CLEAN",M,DHQ,,MVVM5,MVVM9,1,Data produced by the models should be reliable and of high quality
84,"Implementing ViewModel might involve directly calling the Webservice to fetch the data and assign this data to our LiveData object. This design works, but by using it, our app becomes more and more difficult to maintain as it grows. Additionally, the scope of a ViewModel is tied to an Activity or Fragment lifecycle, which means that the data from the Webservice is lost when the associated UI object's lifecycle ends. This behavior creates an undesirable user experience.",B,MVVM,VM,MAN,,MVVM9,MVVM10,1,Networking or data access is performed only by M.