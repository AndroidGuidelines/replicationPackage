ID,RawPractice,Type,Theme,Sub-theme,Sub-sub-theme,GuidelineID,NewGuidelineID,OccurrencyGuideline,,Component,Activity,Fragment,BroadcastReceiver,Service,ContentProvider,Manifest,LayoutXML,JetPack
197-198,"Create maps of dependencies. This is very useful if you want to reuse the same artifact version across different modules in your project, or maybe the other way around, where you have to apply different dependency versions to different modules. Another plus one, is that you also control the dependencies in one place and, for instance, bumping an artifact version is pretty straightforward.",G,GEN,INTER,DEP,GEN20,Gen1,18,Decouple components and explicitly inject/manage the dependencies among them,,,,,,,,,
33,Use Dagger,G,GEN,LIB,DAG,GEN20,Gen1,18,Decouple components and explicitly inject/manage the dependencies among them,,,,,,,,,
99,It’s recommended to use Dependency Injection (cough….Dagger….cough) or Service Locator pattern to manage dependencies between the components.,G,GEN,LIB,DAG,GEN20,Gen1,18,Decouple components and explicitly inject/manage the dependencies among them,,,,,,,,,
116,Dagger2 is used to avoid detailcomplicated boilerplate code of connecting architecture elements one to another.,G,GEN,LIB,DAG,GEN20,Gen1,18,Decouple components and explicitly inject/manage the dependencies among them,,,,,,,,,
123,By injecting mock implementations of respective dependencies to separated classes can make testing much easier.,G,GEN,LIB,DAG,GEN20,Gen1,18,Decouple components and explicitly inject/manage the dependencies among them,,,,,,,,,
212,"[Through dagger] we can manage the scope of our instances created, which is something really cool and from my point of view, Any object or collaborator in your app should not know anything about instances creation and lifecycle and this should be managed by our dependency injection framework.",G,GEN,LIB,DAG,GEN20,Gen1,18,Decouple components and explicitly inject/manage the dependencies among them,,x,x,x,x,x,,,
194,"Use Dagger as (i) components become reusable (since dependencies can be injected and configured externally), (ii) when injecting abstractions as collaborators, we can just change the implementation of any object without having to make a lot of changes in our codebase, (iii) Dependencies can be injected into a component: it is possible to inject mock implementations of these dependencies which makes testing easier.",G,GEN,LIB,DAG,GEN20,Gen1,18,Decouple components and explicitly inject/manage the dependencies among them,,,,,,,,,
213,"The @PerActivity is a custom scoping annotation to permit objects whose lifetime should conform to the life of the activity to be memorized in the correct component. I really encourage to do this as a good practice, since we get these advantages: The ability to inject objects where and activity is required to be constructed. The use of singletons on a peractivity basis. The global object graph is kept clear of things that can be used only in activities.",G,GEN,LIB,DAG,GEN20,Gen1,18,Decouple components and explicitly inject/manage the dependencies among them,,x,,,,,,,
112,"My second tip is to have a core module which will have these main responsitilities: * Handle global dependency injection. * Contain extension functions. * Contain the main framework abstractions. * Initiate in the main application common 3rd party libraries like Analytics, Crash Reporting, etc.",G,GEN,LIB,DAG,GEN20,Gen1,18,Decouple components and explicitly inject/manage the dependencies among them,,,,,,,,,
103,"Having DI framework is not a must, you can live without it, but right setup of DI can really make your life easier. There are several libraries which offer ready solutions (e.g. Dagger, Roboguice, Toothpick). You can decide which one will fit best in your project, considering performance and usability. With dependency injection you don’t have to care so much about things like e.g. object creation, passing references, implementing singleton pattern.",G,GEN,LIB,DAG,GEN20,Gen1,18,Decouple components and explicitly inject/manage the dependencies among them,,,,,,,,,
104,"I think it is a good practice to wrap libraries with a layer of abstraction, this way you can avoid dependencies from particular library implementation inside your business logic. Also if you decide to change a library to a different one, you won’t have to do refactoring in the entire project, just inside a single repository. It is not necessary to use this pattern for everything, only for libraries which you are not confident you will be using in the future.",G,GEN,LIB,DAG,GEN20,Gen1,18,Decouple components and explicitly inject/manage the dependencies among them,,,,,,,,,
86,"The UserRepository class above needs an instance of Webservice to fetch the user's data. It could simply create the instance, but to do that, it also needs to know the dependencies of the Webservice class. Additionally, UserRepository is probably not the only class that needs a Webservice. This situation requires us to duplicate code, as each class that needs a reference to Webservice needs to know how to construct it and its dependencies. If each class creates a new WebService, our app could become very resource heavy. You can use the following design patterns to address this problem: - Dependency injection (DI): Dependency injection allows classes to define their dependencies without constructing them. At runtime, another class is responsible for providing these dependencies. We recommend the Dagger 2 library for implementing dependency injection in Android apps. Dagger 2 automatically constructs objects by walking the dependency tree, and it provides compiletime guarantees on dependencies. - Service locator: The service locator pattern provides a registry where classes can obtain their dependencies instead of constructing them. - It's easier to implement a service registry than use DI, so if you aren't familiar with DI, use the service locator pattern instead. - These patterns allow you to scale your code because they provide clear patterns for managing dependencies without duplicating code or adding complexity. Furthermore, these patterns allow you to quickly switch between test and production datafetching implementations. Our example app uses Dagger 2 to manage the Webservice object's dependencies.",M,GEN,"LIB,DEV",DAG,GEN20,Gen1,18,Decouple components and explicitly inject/manage the dependencies among them,,,,,,,,,
85,"Note: If you're already using a library like RxJava or Agera, you can continue using them instead of LiveData. When you use libraries and approaches like these, however, make sure you handle your app's lifecycle properly. In particular, make sure to pause your data streams when the related LifecycleOwner is stopped and to destroy these streams when the related LifecycleOwner is destroyed. You can also add the android.arch.lifecycle:reactivestreams artifact to use LiveData with another reactive streams library, such as RxJava2.",G,GEN,LIB,RX,GEN20,Gen1,18,Decouple components and explicitly inject/manage the dependencies among them,,,,,,,,,
153,"RxJava allows you to manage data via asynchronous streams and gives you many operators that you can apply to the stream in order to transform, filter or combine the data.",G,GEN,LIB,RX,GEN20,Gen1,18,Decouple components and explicitly inject/manage the dependencies among them,,,,,,,,,
155,RxJava Observables and operators remove the need for having nested callbacks.,G,GEN,LIB,RX,GEN20,Gen1,18,Decouple components and explicitly inject/manage the dependencies among them,,,,,,,,,
218,"We realised there are several ways to use RxJava. The most straightforward one is for asynchronous calls, where you subscribe to an Observable that will eventually emit onNext or onError and complete afterwards, a typical example of this are the observables from retrofit calls. It’s like a callback on steroids, you can control the threads where things are executed very easily and there’s a bunch of very powerful operators that allow you to combine/transform the result.",G,GEN,LIB,RX,GEN20,Gen1,18,Decouple components and explicitly inject/manage the dependencies among them,,,,,,,,,
252,"[On clean ark] Although it’s a bit hidden, the same data flow inversion principle still holds, because without RxJava presenters were implementing the callback, and with RxJava subscribers are also contained in the outer layer – somewhere in the presenter.",G,"GEN,CLEAN",LIB,RX,GEN20,Gen1,18,Decouple components and explicitly inject/manage the dependencies among them,F,,,,,,,,
191,benefits we get out of this RxJava: Decoupling between Observables and Subscribers: makes maintainability and testing easier.,G,GEN,LIB,RX,GEN20,Gen1,18,Decouple components and explicitly inject/manage the dependencies among them,,,,,,,,,
235,"As Robert Martin, aka Uncle Bob, says, “Your architecture should scream the purpose of the app.” More technically said, business logic should be clearly separated and independent of the framework.",G,GEN,AA,,GEN16,Gen2,17,"Design components as independent entities as possibile, build them around the business domain (features of the app) and make them Android-independent",,,,,,,,,
236,"Satisfy a multitude of stakeholders: all interactions are separated in the classes/modules/components/whatever whose job is interactions, and that particular developer works only on those components while working on the UX part of the app.",G,GEN,AA,,GEN16,Gen2,17,"Design components as independent entities as possibile, build them around the business domain (features of the app) and make them Android-independent",,,,,,,,,
9,"We did not separate common functionality in base fragments and activities, but had one different for each, reducing maintainability.",B,GEN,ACT,,GEN16,Gen2,17,"Design components as independent entities as possibile, build them around the business domain (features of the app) and make them Android-independent",,x,x,,,,,,
49,Do not use too many small activities. The purpose of each activity should be easy to be explained,B,GEN,ACT,,GEN16,Gen2,17,"Design components as independent entities as possibile, build them around the business domain (features of the app) and make them Android-independent",,x,,,,,,,
24,[BAD] No clear separation of responsibility,B,GEN,DEV,,GEN16,Gen2,17,"Design components as independent entities as possibile, build them around the business domain (features of the app) and make them Android-independent",,,,,,,,,
210,Decoupled code makes it easy to focus your attention on specific issues without a lot of bloatware getting in the way,G,GEN,DEV,,GEN16,Gen2,17,"Design components as independent entities as possibile, build them around the business domain (features of the app) and make them Android-independent",,,,,,,,,
10,Adhere to the KISS principle. :),G,GEN,DEV,,GEN16,Gen2,17,"Design components as independent entities as possibile, build them around the business domain (features of the app) and make them Android-independent",,,,,,,,,
30,"[BAD] Event driven programming, if no interfaces are used bad, or do not provide basic functions in base classes (also to avoid code duplicates).",B,GEN,DEV,,GEN16,Gen2,17,"Design components as independent entities as possibile, build them around the business domain (features of the app) and make them Android-independent",,,,,,,,,
106,"Feature switching: This is not really something that you must have, but in some cases it can be useful. Feature switching basically allows you to configure set of features/screens which should be enabled in the app, this could be done via local configuration or remotely (e.g Firebase Remote Config). I especially recommend to have remote feature switching if your application contains functionality dependent on external web services. If external API fails, dependent features in your app will stop working as well. In such situation you should disable broken feature ASAP to avoid annoying users. If you have a remote configuration setup you can just disable given feature in remote console, until the API starts working again.",G,GEN,DEV,,GEN16,Gen2,17,"Design components as independent entities as possibile, build them around the business domain (features of the app) and make them Android-independent",,,,,,,,,
115,Minimize framework (android) dependencies in your project as much as you can.,G,GEN,INTER,DEP,GEN16,Gen2,17,"Design components as independent entities as possibile, build them around the business domain (features of the app) and make them Android-independent",,,,,,,,,
199,Minimize framework (android) dependencies in your project as much as you can.,G,GEN,INTER,DEP,GEN16,Gen2,17,"Design components as independent entities as possibile, build them around the business domain (features of the app) and make them Android-independent",,,,,,,,,
16,Core logic should be testable,G,GEN,,,GEN16,Gen2,17,"Design components as independent entities as possibile, build them around the business domain (features of the app) and make them Android-independent",,,,,,,,,
232,"It’s all about decoupling your business logic from the outside world (meaning frameworks, implementation details, etc.) and ending up with the maintainable, testable and with low technical debt application",G,GEN,,,GEN16,Gen2,17,"Design components as independent entities as possibile, build them around the business domain (features of the app) and make them Android-independent",,,,,,,,,
238,"Run away from the real world (Android, DB, Internet…). We have already said that we want to scream what the app really does; that’s it. We want to emphasize business logic and leave framework details under the hood. This point should be even stronger: we would like to not only hide framework details but all the details related to the outside world.",G,GEN,,,GEN16,Gen2,17,"Design components as independent entities as possibile, build them around the business domain (features of the app) and make them Android-independent",,,,,,,,,
239,"Enable your components to be testable. You should unit test your app as much as possible and your architecture should allow you to do it. If you can’t unit test everything, you should at least cover your business logic with tests. Separation from the real world goes nicely with this. It’s easier to test your business logic if it is clearly separated from the rest of the app.",G,GEN,,,GEN16,Gen2,17,"Design components as independent entities as possibile, build them around the business domain (features of the app) and make them Android-independent",,,,,,,,,
65,The coupling between components should be weak to avoid the modification of other components if one is modified.,G,GEN,,,GEN16,Gen2,17,"Design components as independent entities as possibile, build them around the business domain (features of the app) and make them Android-independent",G,GEN,65,The coupling between components should be weak to avoid the modification of other components if one is modified.,G,GEN,,,
71,"Android does not directly support a general reuse model, since Android fragments must have a UI. To reuse common functionality, that does not have its own UI, a reuse model is required that is tailored to activities.",G,GEN,,,GEN16,Gen2,17,"Design components as independent entities as possibile, build them around the business domain (features of the app) and make them Android-independent",G,GEN,71,"Android does not directly support a general reuse model, since Android fragments must have a UI. To reuse common functionality, that does not have its own UI, a reuse model is required that is tailored to activities.",G,GEN,,,
1,Do not do too much in activities and fragments,B,GEN,ACT,,GEN2,Gen3,16,"Counter the tendency of Activities to grow too big in size, e.g. due to functionality/responsability bloat. ",,x,x,,,,,,
6,When developing a base activities make sure that it can be easy be used by inherited classes,G,GEN,DEV,,GEN2,Gen3,16,"Counter the tendency of Activities to grow too big in size, e.g. due to functionality/responsability bloat. ",,x,,,,,,,
81,"2) Modelviewcontroller antipattern. Another poor separation of concerns occurs due to Android’s design that breaks the ModelViewController (MVC) architectural pattern (Krasner et al., 1988; Taylor et al., 2009). In that pattern, a View component provides graphical depictions of information; a Model component contains information to be depicted; and a Controller component maintains consistency between the Model and View. In Android, a Content Provider acts as a Model; the responsibilities of the View and Controller are integrated into one component, an Activity (cf. Section 4.1). This violates the singleresponsibility design principle (Gamma et al., 1994), resulting in a poor separation of concerns that breaks the MVC pattern (Sokolova et al., 2013). This design decision results in an architectural antipattern (Brown et al., 1998), which is a recurring set of architectural elements that together negatively affects the architecture of a system, and renders the system more complex and less maintainable. For example, testing the operations of the View and Controller in Android cannot be done separately Discourages development of “bloated” Activity components that suffer from increased memory footprints and de creased efficiency.",,,,,"GEN2,GEN8",Gen3,"16, 14","Counter the tendency of Activities to grow too big in size, e.g. due to functionality/responsability bloat. The app architecture should embrace and encourage separation of concerns in different modules. Modules should possess well defined responsibility boundaries, a purpose, (set of) functionality, and configuration. ",,,,,,,,,
23,[BAD] God object,B,GEN,ACT,,GEN2,Gen3,16,"Counter the tendency of Activities to grow too big in size, e.g. due to functionality/responsability bloat. ",,,,,,,,,
32,Do not throw everything in an activity,G,GEN,ACT,,GEN2,Gen3,16,"Counter the tendency of Activities to grow too big in size, e.g. due to functionality/responsability bloat. ",,x,,,,,,,
38,Do not put logic in the views,B,GEN,ACT,,GEN2,Gen3,16,"Counter the tendency of Activities to grow too big in size, e.g. due to functionality/responsability bloat. ",,x,x,,,,,,
43,Avoid God Classes by creating a superactivity,B,GEN,ACT,,GEN2,Gen3,16,"Counter the tendency of Activities to grow too big in size, e.g. due to functionality/responsability bloat. ",,x,,,,,,,
82,Activities and Fragments should only contain logic that handles UI and operating system interactions.,G,GEN,ACT,,GEN2,Gen3,16,"Counter the tendency of Activities to grow too big in size, e.g. due to functionality/responsability bloat. ",,x,x,,,,,,
139,Use a single activity for the whole flow,G,GEN,ACT,,GEN2,Gen3,16,"Counter the tendency of Activities to grow too big in size, e.g. due to functionality/responsability bloat. ",,x,,,,,,,
150,Activities and Fragments become very large and difficult to maintain,B,GEN,ACT,,GEN2,Gen3,16,"Counter the tendency of Activities to grow too big in size, e.g. due to functionality/responsability bloat. ",,x,x,,,,,,
152,"Unit testing becomes challenging, if not impossible, because a lot of the logic lives within the Activities or Fragments that are arduous to unit test.",B,GEN,ACT,,GEN2,Gen3,16,"Counter the tendency of Activities to grow too big in size, e.g. due to functionality/responsability bloat. ",,x,x,,,,,,
161,"Activities and Fragments become very lightweight. Their only responsibilities are to set up/update the UI and handle user events. Therefore, they become easier to maintain.",G,GEN,ACT,,GEN2,Gen3,16,"Counter the tendency of Activities to grow too big in size, e.g. due to functionality/responsability bloat. ",,,,,,,,,
240,"God Activity: We have an activity that touches databases, goes to the Internet, does parsing, spawns threads, and renders data. So, all the stakeholders are looking at the single class, none of the concerns is separated, it’s not testable, and business logic is mixed with the Android stuff.",B,GEN,ACT,,GEN2,Gen3,16,"Counter the tendency of Activities to grow too big in size, e.g. due to functionality/responsability bloat. ",,x,,,,,,,
254,Activities were often bloated with multiple responsibilities. There was a lot of code duplication custom views and custom logic.,B,GEN,ACT,,GEN2,Gen3,16,"Counter the tendency of Activities to grow too big in size, e.g. due to functionality/responsability bloat. ",,x,,,,,,,
64,"Parts of code integrated into single Activity cannot be reused, methods can only be copied to another Activity making the redundant code. Any additional View and action complicates the Activity. A modification of one action repeating on several screens requires modification in all related Activities (assuming one Activity per screen). Activity can contain the implementation of very different actions non related to each other, this can make the Activity very complex, unreadable and incomprehensible. Activity is kept in memory while the application is running, thereby a very big Activity affects performance. Finally, the modification in the user interface and application logic can lead to the need of full redevelopment of all Activities.",B,GEN,,,GEN2,Gen3,16,"Counter the tendency of Activities to grow too big in size, e.g. due to functionality/responsability bloat. ",B,GEN,64,"Parts of code integrated into single Activity cannot be reused, methods can only be copied to another Activity making the redundant code. Any additional View and action complicates the Activity. A modification of one action repeating on several screens requires modification in all related Activities (assuming one Activity per screen). Activity can contain the implementation of very different actions non related to each other, this can make the Activity very complex, unreadable and incomprehensible. Activity is kept in memory while the application is running, thereby a very big Activity affects performance. Finally, the modification in the user interface and application logic can lead to the need of full redevelopment of all Activities.",B,GEN,,,
70,Developer should avoid high hierarchy between Fragments within a single Activity as parent Fragment is linked to the child Fragments. Activities make components more independent and simplifies the Fragment management.,G,GEN,,,GEN2,Gen3,16,"Counter the tendency of Activities to grow too big in size, e.g. due to functionality/responsability bloat. ",G,GEN,70,Developer should avoid high hierarchy between Fragments within a single Activity as parent Fragment is linked to the child Fragments. Activities make components more independent and simplifies the Fragment management.,G,GEN,,,
46,No more than 1.000 lines per component\class,B,GEN,INTER,SEP,GEN8,Gen4,14,"The app architecture should embrace and encourage separation of concerns in different modules. Modules should possess well defined responsibility boundaries, a purpose, (set of) functionality, and configuration. ",,,,,,,,,
47,Methods should be kept small,B,GEN,INTER,SEP,GEN8,Gen4,14,"The app architecture should embrace and encourage separation of concerns in different modules. Modules should possess well defined responsibility boundaries, a purpose, (set of) functionality, and configuration. ",,,,,,,,,
11,"when talking about module, we have a feature A and feature B, it is good to separate into two submodules.",G,GEN,INTER,SEP,GEN8,Gen4,14,"The app architecture should embrace and encourage separation of concerns in different modules. Modules should possess well defined responsibility boundaries, a purpose, (set of) functionality, and configuration. ",,,,,,,,,
48,Respect separation of concern at method level,G,GEN,INTER,SEP,GEN8,Gen4,14,"The app architecture should embrace and encourage separation of concerns in different modules. Modules should possess well defined responsibility boundaries, a purpose, (set of) functionality, and configuration. ",,,,,,,,,
51,"[...] the application structure consists of a set of monolithic classes. These classes group almost all project code in a few classes, thus this application does not present a well modularized architecture.",B,GEN,INTER,SEP,GEN8,Gen4,14,"The app architecture should embrace and encourage separation of concerns in different modules. Modules should possess well defined responsibility boundaries, a purpose, (set of) functionality, and configuration. ",,,,,,,,,
105,"Separating project into a few modules should give you some profits. You can have abstract layers physically located in different modules, each module has its own build configuration, so you can customize dependencies for each of them. For example UI module doesn’t have to see database or network models, and low level modules don’t have to access libraries for animations, UI binding etc. With Android Gradle Plugin 3.0 or higher, modularization also increases building speed and makes solid fundaments for developing Instant Apps. Keep in mind, that modularization will be easy to achieve and low at cost at the beginning of project development, but when project is mature it will require much more effort.",G,GEN,INTER,SEP,GEN8,Gen4,14,"The app architecture should embrace and encourage separation of concerns in different modules. Modules should possess well defined responsibility boundaries, a purpose, (set of) functionality, and configuration. ",,,,,,,,,
92,"Create welldefined boundaries of responsibility between various modules of your app. For example, don't spread the code that loads data from the network across multiple classes or packages in your code base. Similarly, don't define multiple unrelated responsibilities—such as data caching and data binding—into the same class.",G,GEN,INTER,SEP,GEN8,Gen4,14,"The app architecture should embrace and encourage separation of concerns in different modules. Modules should possess well defined responsibility boundaries, a purpose, (set of) functionality, and configuration. ",,,,,,,,,
237,"Encourage separation of concerns. What I have said before is an example of separation of concerns. We encourage that particular approach because it maps nicely to the organization of teams and project phases, but your architecture should also encourage separation of concerns generally. Separation of concerns, or the single responsibility principle, says that every component should have only one reason to change.",G,GEN,INTER,SEP,GEN8,Gen4,14,"The app architecture should embrace and encourage separation of concerns in different modules. Modules should possess well defined responsibility boundaries, a purpose, (set of) functionality, and configuration. ",,,,,,,,,
94,"Consider how to make each module testable in isolation. For example, having a welldefined API for fetching data from the network makes it easier to test the module that persists that data in a local database. If, instead, you mix the logic from these two modules in one place, or distribute your networking code across your entire code base, it becomes much more difficult—if not impossible—to test.",G,GEN,INTER,"SEP, INT",GEN8,Gen4,14,"The app architecture should embrace and encourage separation of concerns in different modules. Modules should possess well defined responsibility boundaries, a purpose, (set of) functionality, and configuration. ",,,,,,,,,
141,"[A Component] Has a single, well defined responsibility. The most important property of a Component is it should do just one thing. Nearly all Components in our app are currently about 100 –120 lines. When a Component starts getting bigger, we break it into more Components.",G,GEN,INTRA,SEP,GEN8,Gen4,14,"The app architecture should embrace and encourage separation of concerns in different modules. Modules should possess well defined responsibility boundaries, a purpose, (set of) functionality, and configuration. ",,,,,,,,,
18,[GOOD] Separation of responsibility: one component should do only one thing good,G,GEN,INTER,SEP,GEN8,Gen4,14,"The app architecture should embrace and encourage separation of concerns in different modules. Modules should possess well defined responsibility boundaries, a purpose, (set of) functionality, and configuration. ",,,,,,,,,
25,[BAD] Not using a dedicated business logic layer,B,GEN,INTRA,SEP,GEN8,Gen4,14,"The app architecture should embrace and encourage separation of concerns in different modules. Modules should possess well defined responsibility boundaries, a purpose, (set of) functionality, and configuration. ",,,,,,,,,
26,[BAD] Not using a dedicated data holding layer,B,GEN,INTRA,SEP,GEN8,Gen4,14,"The app architecture should embrace and encourage separation of concerns in different modules. Modules should possess well defined responsibility boundaries, a purpose, (set of) functionality, and configuration. ",,,,,,,,,
2,"Stick to a precise architecture, e.g. MVP and MVVM",G,GEN,AA,,GEN1,Gen5,10,"When starting a new project, select an appropriate architectural style to adhere to (e.g. MVP or MVVM). This is done in order to have clearly separated components, roles, and responsibilities.",,,,,,,,,
5,"When starting a new project, use directly MVP",G,GEN,AA,,GEN1,Gen5,10,"When starting a new project, select an appropriate architectural style to adhere to (e.g. MVP or MVVM). This is done in order to have clearly separated components, roles, and responsibilities.",,,,,,,,,
15,"Separate the code into the components of MVP, MVC",G,GEN,AA,,GEN1,Gen5,10,"When starting a new project, select an appropriate architectural style to adhere to (e.g. MVP or MVVM). This is done in order to have clearly separated components, roles, and responsibilities.",,,,,,,,,
28,[BAD] Singleton,B,GEN,AA,,GEN1,Gen5,10,"When starting a new project, select an appropriate architectural style to adhere to (e.g. MVP or MVVM). This is done in order to have clearly separated components, roles, and responsibilities.",,,,,,,,,
34,"Use a separate model for the network, then create a model internal to the app",G,GEN,AA,,GEN1,Gen5,10,"When starting a new project, select an appropriate architectural style to adhere to (e.g. MVP or MVVM). This is done in order to have clearly separated components, roles, and responsibilities.",,,,,,,,,
42,Architecture needs to be in line with the project,G,GEN,AA,,GEN1,Gen5,10,"When starting a new project, select an appropriate architectural style to adhere to (e.g. MVP or MVVM). This is done in order to have clearly separated components, roles, and responsibilities.",,,,,,,,,
168,MVVM can not be justified for small projects.,B,GEN,AA,,GEN1,Gen5,10,"When starting a new project, select an appropriate architectural style to adhere to (e.g. MVP or MVVM). This is done in order to have clearly separated components, roles, and responsibilities.",,,,,,,,,
229,"[...] Onion Architecture, Hexagonal Architecture (also known as Ports and Adapters) and the popular Clean Architecture, among other layered architectures. Though these approximations have their own fancy names and could seem completely different, they share a lot in common. In fact, its main intent is the same: Achieve a highlevel separation of concerns by layering.",G,GEN,AA,,GEN1,Gen5,10,"When starting a new project, select an appropriate architectural style to adhere to (e.g. MVP or MVVM). This is done in order to have clearly separated components, roles, and responsibilities.",,,,,,,,,
230,[General on styles] There are a lot of scenarios where we aren’t gonna need that level of adaptability. Especially in mobile applications in which the domain logic is really close to the view. Prematurely creating that kind of indirection and isolation is usually a waste of time and it may be a bit overkill.,B,GEN,AA,,GEN1,Gen5,10,"When starting a new project, select an appropriate architectural style to adhere to (e.g. MVP or MVVM). This is done in order to have clearly separated components, roles, and responsibilities.",,,,,,,,,
118,"Another important thing is different entities for each layer of application. As dependency inversion principle works in the other way works additional fields decreasing. The purpose of different entities for each layer is to reduce the amount of information inner layer may depend on. E.g., you don’t need api version at your entity in domain and presentation layers of your application, you only need this property in data layers.",G,GEN,,,GEN1,Gen5,10,"When starting a new project, select an appropriate architectural style to adhere to (e.g. MVP or MVVM). This is done in order to have clearly separated components, roles, and responsibilities.",,,,,,,,,
29,"[BAD] Directory/file structure should be tidy: if there is a mix in the folders, there is a mix also in the code, similar stuff should go in the same folder/subfolders.",B,GEN,PKG,,GEN14,Gen6,8,Organize your Java/Kotlin packages either by layer or app feature.,,,,,,,,,
45,Use a tidy folder structure and file layout,G,GEN,PKG,,GEN14,Gen6,8,Organize your Java/Kotlin packages either by layer or app feature.,,,,,,,,,
55,3) We also analysed the package organization of each selected application in order to identify whether the separation into architectural components as reflected in the package structure.,G,GEN,PKG,,GEN14,Gen6,8,Organize your Java/Kotlin packages either by layer or app feature.,,,,,,,,,
56,"3.1) many applications grouped their classes based on the MVC components, creating a separated package for each architectural component (model, view or controller)",G,GEN,PKG,,GEN14,Gen6,8,Organize your Java/Kotlin packages either by layer or app feature.,,,,,,,,,
57,"3.2) On the other hand, some applications have grouped their classes according to the business concern.",G,GEN,PKG,,GEN14,Gen6,8,Organize your Java/Kotlin packages either by layer or app feature.,,,,,,,,,
111,Code/package organization is one of the key factors of a good architecture: package structure is the very first thing encountered by a programmer when browsing source code. Everything flows from it. Everything depends on it.,G,GEN,PKG,,GEN14,Gen6,8,Organize your Java/Kotlin packages either by layer or app feature.,,,,,,,,,
195,I consider code/package organization one of the key factors of a good architecture: package structure is the very first thing encountered by a programmer when browsing source code. Everything flows from it. Everything depends on it. Either package by layer of functionality.,G,GEN,PKG,,GEN14,Gen6,8,Organize your Java/Kotlin packages either by layer or app feature.,,,,,,,,,
256,"For example, you should be able to look at a package structure and understand how it’s organized. I often think about this from the perspective of writing open source code: would my code be apparent to I don’t know, and who isn’t on my team?",G,GEN,PKG,,GEN14,Gen6,8,Organize your Java/Kotlin packages either by layer or app feature.,,,,,,,,,
22,"[BAD] Not using the compatibility library (makes new features backwards compatible), called “compat library”.",B,GEN,LIB,WHEEL,GEN11,Gen7,7,Take full advantage of libraries. Do not try to reinvent the wheel and loose time by implementing boilerplate code. Focus on what makes your app stand out from the rest and delegate what is left to libraries.,,,,,,,,,
41,Use a library to manage images,G,GEN,LIB,WHEEL,GEN11,Gen7,7,Take full advantage of libraries. Do not try to reinvent the wheel and loose time by implementing boilerplate code. Focus on what makes your app stand out from the rest and delegate what is left to libraries.,,,,,,,,,
95,"Focus on the unique core of your app so it stands out from other apps. Don't reinvent the wheel by writing the same boilerplate code again and again. Instead, focus your time and energy on what makes your app unique, and let the Android Architecture Components and other recommended libraries handle the repetitive boilerplate.",G,GEN,LIB,WHEEL,GEN11,Gen7,7,Take full advantage of libraries. Do not try to reinvent the wheel and loose time by implementing boilerplate code. Focus on what makes your app stand out from the rest and delegate what is left to libraries.,,,,,,,,,
171,"Don’t Reinvent the Wheel. Initially, I had a bad idea of not using opensource libraries. Whatever I needed, I just wanted to make it myself. It’s was seriously a terrible idea. Focus more on the core business logic of your app. If you want to make network calls in your app, you don’t need to make a Retrofit yourself.",M,GEN,LIB,WHEEL,GEN11,Gen7,7,Take full advantage of libraries. Do not try to reinvent the wheel and loose time by implementing boilerplate code. Focus on what makes your app stand out from the rest and delegate what is left to libraries.,,,,,,,,,
172,"There are lots and lots of opensource libraries available in Github for you to use for FREE. But don’t get too excited and start using libraries blindly. Check the number of stars that particular library has, the more the better. Check if the author of that library have also created some other popular libraries as well. Check the issues (both open and closed), which can give you a better idea of how robust and stable the library is in production. If you can afford the time, you should dive into the code of that library and check yourself if its really worth it.",M,GEN,LIB,WHEEL,GEN11,Gen7,7,Take full advantage of libraries. Do not try to reinvent the wheel and loose time by implementing boilerplate code. Focus on what makes your app stand out from the rest and delegate what is left to libraries.,,,,,,,,,
174,"Never ever, ever make the mistake of releasing your app on the Play Store without using ProGuard. ProGuard not only minifies your code, but it obfuscates your code making it harder for reverseengineers to understand, replicate and manipulate it.",B,GEN,LIB,WHEEL,GEN11,Gen7,7,Take full advantage of libraries. Do not try to reinvent the wheel and loose time by implementing boilerplate code. Focus on what makes your app stand out from the rest and delegate what is left to libraries.,,,,,,,,,
269,"Use as much as possible the Android components, e.g. someone used a bloatware custom dock instead of using stock Android library.",G,GEN,LIB,WHEEL,GEN11,Gen7,7,Take full advantage of libraries. Do not try to reinvent the wheel and loose time by implementing boilerplate code. Focus on what makes your app stand out from the rest and delegate what is left to libraries.,,,,,,,,,
96,"Persist as much relevant and fresh data as possible. That way, users can enjoy your app's functionality even when their device is in offline mode. Remember that not all of your users enjoy constant, highspeed connectivity.",G,GEN,DATA,,GEN17,Gen8,7,Locally cache data for supporting offline-first experience,,,,,,,,,
138,"If the app isn't designed with care, it can request data that it doesn't need, which places a performance burden on the device, and on the network. If the data is stored or synchronized with a remote database, this can also slow the app and waste the user's data plan. The paging library addresses issues with existing solutions.",G,GEN,DATA,,GEN17,Gen8,7,Locally cache data for supporting offline-first experience,,,,,,,,,
202,"In Android screen orientation change is a challenging problem. The simplest way to deal with that is to ignore it. Just reload everything on each screen orientation change. This is a completely valid solution. Most of the time your app works offline too so that data comes from a local database or another local cache. Therefore, loading data is superfast after screen orientation changes. However, I personally dislike seeing a loading indicator [...]",B,GEN,DATA,,GEN17,Gen8,7,Locally cache data for supporting offline-first experience,,x,x,,,,,,
20,"[GOOD] Network connectivity should be handled with care, local caching through error handling.",G,GEN,CONN,,GEN4,Gen8,7,"Locally cache data for supporting offline-first experience
",,,,,,,,,
132,"By relying on our current implementation in this situation, we need to fetch the data again from the network. This refetching process isn't just a bad user experience; it's also wasteful because it consumes valuable mobile data. You could fix this issue by caching the web requests, but that creates a key new problem: What happens if the same user data shows up from another type of request, such as fetching a list of friends? The app would show inconsistent data, which is confusing at best. The proper way to handle this situation is to use a persistent model. This is where the Room persistence library comes to the rescue.",M,MVVM,M,"LDBN,SST",,"Gen8, MVVM2",7,"Locally cache data for supporting offline-first experience
","Presenter should be stateless. Presenter's lifecycle should follow the lifecycle of the View, but not replicating the complexity of Android's components lifecycles.",,,,,,,,
100,"Most modern Android apps maintain a synchronization between local database and the web service, this is super useful for users which helps in using the app even if the device is offline. This is something which users have started to nowadays expect in apps. It [the model] states to first fetch the data from local database; if the data doesn’t exist then make the required network call based upon the “should fetch” condition and then save the fetched data into the local database on response.",G,MVVM,M,LDBN,,Gen8,7,"Locally cache data for supporting offline-first experience
",local DB first then network.,,,,,,,,
21,"[GOOD] Power management, graceful failing, retry when server fails, incremental pinging when server is unresponsive, bundled updates of various app to avoid constant throttling in background.",G,GEN,EN,,GEN4,Gen8,7,"Locally cache data for supporting offline-first experience
",,,,,,,,,
3,"Do not use concrete classes but interfaces, which are more easy to change",M,GEN,DEV,,GEN9,Gen9,6,Use exclusively interfaces to let app modules communicate. This protects the structure and helps defining a clear responsibility for each module.,,,,,,,,,
93,"Expose as little as possible from each module. Don't be tempted to create just that one shortcut that exposes an internal implementation detail from one module. You might gain a bit of time in the short term, but you then incur technical debt many times over as your codebase evolves.",G,GEN,INTER,INT,GEN9,Gen9,6,Use exclusively interfaces to let app modules communicate. This protects the structure and helps defining a clear responsibility for each module.,,,,,,,,,
147,"I started to use interfaces for linking the modules together. That way, they can’t access methods other than the ones declared on the interface. This protects the structure and helps defining a clear responsibility for each module, avoiding developer mistakes like putting the logic in the wrong place.",G,GEN,INTER,INT,GEN9,Gen9,6,Use exclusively interfaces to let app modules communicate. This protects the structure and helps defining a clear responsibility for each module.,,,,,,,,,
69,Fragments should rarely have a callback to parent Fragments but if necessary the callback can be implemented with interfaces.,M,GEN,,,"GEN9, GEN3",Gen9,6,"Use exclusively interfaces to let app modules communicate. This protects the structure and helps defining a clear responsibility for each module. Avoid nested callbacks (aka ""callback hell""). Approximatively, more than 2 levels of callbacks are considered to reduce maintainability and understendability. This problem is usually fixed by adopting RxJava.",GEN,69,Fragments should rarely have a callback to parent Fragments but if necessary the callback can be implemented with interfaces.,M,GEN,,,,
68,To keep components loosely coupled it is recommended to ensure communication between Controllers and Activity via interfaces.,G,GEN,,,GEN9,Gen9,6,,,,,,,,,,
142,"Components have explicitly defined inputs. A component takes all its inputs via the constructor. Specifying, the necessary inputs in the constructor ensures some compile time safety by guaranteeing that we have all values available before creating the Component. Another advantage of explicit inputs is that during testing we can mock these dependencies easily and test the component in isolation.",G,GEN,INTRA,INT,"GEN9, GEN16",Gen9,6,Use exclusively interfaces to let app modules communicate. This protects the structure and helps defining a clear responsibility for each module.,,,,,,,,,
8,"Too many callbacks, such as 2 depth levels of callbacks are hard to read",G,GEN,CALL,,GEN3,Gen10,5,"Avoid nested callbacks (aka ""callback hell""). Approximatively, more than 2 levels of callbacks are considered to reduce maintainability and understendability. This problem is usually fixed by adopting RxJava.",,,,,,,,,
144,"No more jumping between callbacks. In this example app, coroutines also completely removed the need of using RxJava. Functions with suspendable points are easier to read and understand than some RxJava operator chains — these chains can quickly become too functional (Having said that, I don’t think that RxJava can be replaced with coroutines in every use case. Observables give us a different kind of expressiveness that can not be mapped one to one to suspendable functions. In particular once constructed observable operator chain allow many events to flow through it, while a suspendable point resumes only once per invocation)",M,GEN,CALL,,GEN3,Gen10,5,"Avoid nested callbacks (aka ""callback hell""). Approximatively, more than 2 levels of callbacks are considered to reduce maintainability and understendability. This problem is usually fixed by adopting RxJava.",,,,,,,,,
149,"Another common case is when the loadPosts() method takes a parameter that needs to be fetched from somewhere else, for example an email address provided by the Play Services SDK. It’s likely that the SDK will return the email asynchronously using a callback, meaning that we now have three levels of nested callbacks. If we keep adding complexity, this approach will result into what is known as callback hell.",B,MVP,M,CALL,GEN3,Gen10,5,"Avoid nested callbacks (aka ""callback hell""). Approximatively, more than 2 levels of callbacks are considered to reduce maintainability and understendability. This problem is usually fixed by adopting RxJava.",,,,,,,,,
192,"Simplified asynchronous tasks: java threads and futures are complex to manipulate and synchronize if more than one single level of asynchronous execution is required, so by using schedulers we can jump between background and main thread in an easy way (with no extra effort), especially when we need to update the UI. We also avoid what we call a “callback hell”, which makes our code unreadable and hard to follow up.",M,GEN,CALL,,GEN3,Gen10,5,"Avoid nested callbacks (aka ""callback hell""). Approximatively, more than 2 levels of callbacks are considered to reduce maintainability and understendability. This problem is usually fixed by adopting RxJava.",,,,,,,,,
13,Variable and function names should be meaningful.,G,GEN,PKG,,GEN21,Gen11,4,Employ well-defined and accepted coding standards (helps in code understandability and maintainability).,,,,,,,,,
31,[BAD] Naming patterns should be used consistently and with sense.,B,GEN,PKG,,GEN21,Gen11,4,Employ well-defined and accepted coding standards (helps in code understandability and maintainability).,,,,,,,,,
173,"For God’s Sake, Maintain Proper Coding Standards. If you compare coding with writing, then coding standards is like your handwriting. As you would be reading more of others code, other people will also be reading a lot of your code and you don’t want to scare the shit out of them, do you? And if you are working in an organization and collaborating with other developers heavily, do take special care about it. Write short, clean and readable code that YOU and people reading your code would enjoy thoroughly. Your code should read like a story.",M,GEN,PKG,,GEN21,Gen11,4,Employ well-defined and accepted coding standards (helps in code understandability and maintainability).,,,,,,,,,
196,Organize your build logic (Gradle) and group stuff by functionality in separate gradle build files.,G,GEN,PKG,,GEN21,Gen11,4,"Design components as independent entities as possibile, build them around the business domain (features of the app) and make them Android-independent",,,,,,,,,
12,"DataStorage, if put into a dedicated submodule it is easier to maintain.",G,GEN,DATA,,GEN5,Gen12,3,Use a dedicated module to persist as much relevant data as possible. This data source should be the single source of truth driving the UI.,,,,,,,,,
97,"Assign one data source to be the single source of truth. Whenever your app needs to access this piece of data, it should always originate from this single source of truth.",G,GEN,DATA,,GEN5,Gen12,3,Use a dedicated module to persist as much relevant data as possible. This data source should be the single source of truth driving the UI.,,,,,,,,,
101,"Remember, your UI should always reflect based on the data in the database.",G,GEN,DATA,,GEN5,Gen12,3,Use a dedicated module to persist as much relevant data as possible. This data source should be the single source of truth driving the UI.,,,,,,,,,
91,"Avoid designating your app's entry points—such as activities, services, and broadcast receivers—as sources of data. Instead, they should only coordinate with other components to retrieve the subset of data that is relevant to that entry point. Each app component is rather shortlived, depending on the user's interaction with their device and the overall current health of the system.",M,GEN,"INTRA,INTER",INT,GEN19,Gen13,3,"Design Android components (e.g., Activities and Services) by taking into consideration their lifecycle (also with respect to other components) and as shortlived entities, so to take into consideration user's interaction and system's demands.",,x,x,x,,,,,
134,"Observing changes to data across multiple components of your app can create explicit, rigid dependency paths between the components. This makes testing and debugging, among other things, difficult. To avoid these problems, use LiveData, which is a lifecycle library class for data observation.",B,GEN,INTER,DEP,GEN19,Gen13,3,"Design Android components (e.g., Activities and Services) by taking into consideration their lifecycle (also with respect to other components) and as shortlived entities, so to take into consideration user's interaction and system's demands.",,,,,,,,,
137,"A common pattern is to implement the actions of the dependent components in the lifecycle methods of activities and fragments. However, once you have multiple components, using this pattern leads to poor code organization and a proliferation of errors, such as possible race conditions. Lifecycleaware components perform actions in response to a change in the lifecycle status of another component. For example, a listener could start and stop itself in response to an activity starting and stopping. This results in code that is better organized, usually shorter, and always easier to maintain.",M,GEN,INTER,DEP,GEN19,Gen13,3,"Design Android components (e.g., Activities and Services) by taking into consideration their lifecycle (also with respect to other components) and as shortlived entities, so to take into consideration user's interaction and system's demands.",,x,x,,,,,,
50,Background tasks should not run forever,B,GEN,DEV,,GEN18,Gen14,1,"Have special care of background tasks, specially according to the apps' lifecycle.",,,,,x,,,,
60,"Permission use within apps is consistent, meaning that any component of an app that has a permission must be declared also at the app level. This constraint is defined for each application group.",G,GEN,,,GEN22,Gen15,1,Use permissions consistently. Every component of an app that has a permission must be declared also at the app level.,G,GEN,60,"Permission use within apps is consistent, meaning that any component of an app that has a permission must be declared also at the app level. This constraint is defined for each application group.",G,GEN,,,