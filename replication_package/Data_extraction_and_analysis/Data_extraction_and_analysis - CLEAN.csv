ID,RawPractice,Type,Theme,Component,Sub-theme,Sub-sub-theme,GuidelineID,NewGuidelineID,GuidelineOccurrency,Guideline
120,"Business logic shouldn’t know where the data comes from. Act locally, but sync globally.",G,CLEAN,B,,,CLEAN1,CLEAN1,13,"Business logic should be completely decoupled from the Android framework. Ideally, it could be implemented in pure Java and be changed as little as possible. Additionally, business logic should be completely agnostic to the sources of data and developed before all other layers."
122,Business logic doesn’t touch Android directly anymore and this should result in a decoupled codebase.,G,CLEAN,"B,F",JAVA-ONLY,,CLEAN1,CLEAN1,13,"Business logic should be completely decoupled from the Android framework. Ideally, it could be implemented in pure Java and be changed as little as possible. Additionally, business logic should be completely agnostic to the sources of data and developed before all other layers."
189,"Domain layer: all the logic happens in this layer. Regarding the android project, you will see all the interactors (use cases) implementations here as well. This layer is a pure java module without any android dependencies. All the external components use interfaces when connecting to the business objects.",G,CLEAN,B,,,CLEAN1,CLEAN1,13,"Business logic should be completely decoupled from the Android framework. Ideally, it could be implemented in pure Java and be changed as little as possible. Additionally, business logic should be completely agnostic to the sources of data and developed before all other layers."
205,The business logic layer does not contain any framework specific code and you should be able to run it without an emulator. This layer does not contain any framework specific code and you should be able to run it without an emulator.,G,CLEAN,B,JAVA-ONLY,,CLEAN1,CLEAN1,13,"Business logic should be completely decoupled from the Android framework. Ideally, it could be implemented in pure Java and be changed as little as possible. Additionally, business logic should be completely agnostic to the sources of data and developed before all other layers."
207,"Your business logic models might not be appropriate for showing them to the user directly. Perhaps you need to show a combination of multiple business logic models at once. Therefore, I suggest you create a ViewModel class that makes it easier for you to display it to the UI. Then, you use a converter class in the outer layer to convert your business models to the appropriate ViewModel.",M,CLEAN,B,,,CLEAN1,CLEAN1,13,"Business logic should be completely decoupled from the Android framework. Ideally, it could be implemented in pure Java and be changed as little as possible. Additionally, business logic should be completely agnostic to the sources of data and developed before all other layers."
221,"This layer [domain] sits on top of the data and is responsible for coordinating the actions to the repository. It can also perform some mappings to prepare the objects coming from the data layer, that way the presentation layer can consume them easily. The domain [layer] is 100% Java only, meaning that there are no Android framework related objects here. [Reactive Clean Architecture]",G,"MVVM,CLEAN",,JAVA-ONLY,,CLEAN1,CLEAN1,13,"Business logic should be completely decoupled from the Android framework. Ideally, it could be implemented in pure Java and be changed as little as possible. Additionally, business logic should be completely agnostic to the sources of data and developed before all other layers."
244,"[On clean code ark] domain module. If you want an extra challenge with a reward of eternal glory and a totally clean design, you can make that module a pure Java module. It will prevent you from taking shortcuts and putting something related to the Android here.",,CLEAN,B,JAVA-ONLY,,CLEAN1,CLEAN1,13,"Business logic should be completely decoupled from the Android framework. Ideally, it could be implemented in pure Java and be changed as little as possible. Additionally, business logic should be completely agnostic to the sources of data and developed before all other layers."
247,[On clean ark] We have pushed Android and the realworld stuff as far out on the outskirts as we can. Business logic doesn’t touch the Android directly anymore.,G,CLEAN,GEN,JAVA-ONLY,,CLEAN1,CLEAN1,13,"Business logic should be completely decoupled from the Android framework. Ideally, it could be implemented in pure Java and be changed as little as possible. Additionally, business logic should be completely agnostic to the sources of data and developed before all other layers."
248,[On clean ark] We have nicely separated classes that are easy to test. Classes touching the world can be tested using Android test cases; the one not touching it can be tested using JUnit. Someone malevolent would maybe call that class explosion. I call it testable. :),G,CLEAN,GEN,JAVA-ONLY,,CLEAN1,CLEAN1,13,"Business logic should be completely decoupled from the Android framework. Ideally, it could be implemented in pure Java and be changed as little as possible. Additionally, business logic should be completely agnostic to the sources of data and developed before all other layers."
257,"Layer Models: Enterprise Business Rules: The first layer is the enterprise business rules, the core business rules of our application. For example, Twitter’s rules might be a profile or a tweet. Unless the needs of your business change, you should never need to touch these once they have been created. These can also be created before you write your UI.",G,CLEAN,B,,,CLEAN1,CLEAN1,13,"Business logic should be completely decoupled from the Android framework. Ideally, it could be implemented in pure Java and be changed as little as possible. Additionally, business logic should be completely agnostic to the sources of data and developed before all other layers."
186,"The purpose is the separation of concerns by keeping the business rules not knowing anything at all about the outside world, thus, they can can be tested without any dependency to any external element. To achieve this, my proposal is about breaking up the project into 3 different layers, in which each one has its own purpose and works separately from the others. It is worth mentioning that each layer uses its own data model so this independence can be reached (you will see in code that a data mapper is needed in order to accomplish data transformation, a price to be paid if you do not want to cross the use of your models over the entire application).",G,CLEAN,C,GEN,,CLEAN1,CLEAN1,13,"Business logic should be completely decoupled from the Android framework. Ideally, it could be implemented in pure Java and be changed as little as possible. Additionally, business logic should be completely agnostic to the sources of data and developed before all other layers."
222,"This [presentation layer] is the last layer, responsible for building the objects the views are going to consume and processing the actions performed in this views. This is also the layer where the Android Architecture Components are used, more specifically, the LiveData and the ViewModel.",G,"MVVM,CLEAN",,,,CLEAN1,CLEAN1,13,"Business logic should be completely decoupled from the Android framework. Ideally, it could be implemented in pure Java and be changed as little as possible. Additionally, business logic should be completely agnostic to the sources of data and developed before all other layers."
242,"[MVP, To solve god presenter] introduce some manager. You don’t have to name it “manager.” There are lots of names for these kind of classes: utils, helpers, fooBarBuzzator, etc. So, we introduced managers. Business logic is contained in the manager classes. Stakeholders know where to look at, concerns are sort of separated",G,CLEAN,"P,C",,,CLEAN1,CLEAN1,13,"Business logic should be completely decoupled from the Android framework. Ideally, it could be implemented in pure Java and be changed as little as possible. Additionally, business logic should be completely agnostic to the sources of data and developed before all other layers."
124,"No compulsion to use Presenters to handle presentation logic, we could say that Clean architecture is “frontend” agnostic – meaning we can use MVP, MVVM or anything else on top of it.",G,CLEAN,F,,,CLEAN2,CLEAN2,5,"The outer architectural layer should be composed by Android UI components and should not contain any other logic than UI. The rest of the app architecture should be ""frontend"" agnostic, hence different patterns (MVP, MVVM, etc.) can be adopted in the outer layer."
188,"Fragments and activities are only views, there is no logic inside them other than UI logic, and this is where all the rendering stuff takes place.",G,CLEAN,C,,,CLEAN2,CLEAN2,5,"The outer architectural layer should be composed by Android UI components and should not contain any other logic than UI. The rest of the app architecture should be ""frontend"" agnostic, hence different patterns (MVP, MVVM, etc.) can be adopted in the outer layer."
252,"[On clean ark] Although it’s a bit hidden, the same data flow inversion principle still holds, because without RxJava presenters were implementing the callback, and with RxJava subscribers are also contained in the outer layer – somewhere in the presenter.",G,"GEN,CLEAN",F,,,CLEAN2,CLEAN2,5,"The outer architectural layer should be composed by Android UI components and should not contain any other logic than UI. The rest of the app architecture should be ""frontend"" agnostic, hence different patterns (MVP, MVVM, etc.) can be adopted in the outer layer."
246,"[On clean code ark] we group everything related to the UI (including presenters) into the UI module. You can explicitly name it UI but because of all the Android stuff here, we leave it named “app,” just as Android Studio named it during the creation of the project.",G,CLEAN,F,ANDROID,,CLEAN2,CLEAN2,5,"The outer architectural layer should be composed by Android UI components and should not contain any other logic than UI. The rest of the app architecture should be ""frontend"" agnostic, hence different patterns (MVP, MVVM, etc.) can be adopted in the outer layer."
251,"[On clean ark] The easiest part, app module (UI module). This module is already created for you by the Android studio when you create a project. Here you can place all the classes related to the Android UI such as presenters, controllers, view models, adapters and views.",G,CLEAN,F,ANDROID,,CLEAN2,CLEAN2,5,"The outer architectural layer should be composed by Android UI components and should not contain any other logic than UI. The rest of the app architecture should be ""frontend"" agnostic, hence different patterns (MVP, MVVM, etc.) can be adopted in the outer layer."
222,"This [presentation layer] is the last layer, responsible for building the objects the views are going to consume and processing the actions performed in this views. This is also the layer where the Android Architecture Components are used, more specifically, the LiveData and the ViewModel.",G,"MVVM,CLEAN",,,,CLEAN3,CLEAN3,4,"The framework and devices layer should include everything related to Android, e.g. the data persistence module (LiveData,  ViewModel, DAOs, ORMs, Shared Preferences, Retrofit, etc.) and the UI model. This layer modules should contain all the Android specific implementation details (which should not be present in the business logic layer)."
249,"[On clean ark] The data module should hold everything related to data persistence and manipulation. Here we will find DAOs, ORMs, SharedPreferences, network related stuff like Retrofit services and similar.",G,CLEAN,F,DATA,,CLEAN3,CLEAN3,4,"The framework and devices layer should include everything related to Android, e.g. the data persistence module (LiveData,  ViewModel, DAOs, ORMs, Shared Preferences, Retrofit, etc.) and the UI model. This layer modules should contain all the Android specific implementation details (which should not be present in the business logic layer)."
245,"[On clean code ark] The device module should have everything related to Android that’s not data persistence and UI. The data module should hold everything related to data persistence, as we’ve already said. You cannot make those two into Java modules because they need access to various Android stuff. You can make them into Android library. [...] Data and Device modules contain all of the implementation details that business logic does not care about. It only cares about the contracts, allowing you to easily test it and swap out implementations without touching the business logic. [...] Each data source, both network, and local storage, will have its own models to work with.",G,CLEAN,F,DATA,,CLEAN3,CLEAN3,4,"The framework and devices layer should include everything related to Android, e.g. the data persistence module (LiveData,  ViewModel, DAOs, ORMs, Shared Preferences, Retrofit, etc.) and the UI model. This layer modules should contain all the Android specific implementation details (which should not be present in the business logic layer)."
250,"[On clean ark] The device module should have everything related to Android that’s not data persistence and UI. In example, wrapper classes for ConnectivityManager, NotificationManager and misc sensors. We will make both Data and Device modules android modules, as they must know about Android and cannot be pure java.",G,CLEAN,F,DATA,,CLEAN3,CLEAN3,4,"The framework and devices layer should include everything related to Android, e.g. the data persistence module (LiveData,  ViewModel, DAOs, ORMs, Shared Preferences, Retrofit, etc.) and the UI model. This layer modules should contain all the Android specific implementation details (which should not be present in the business logic layer)."
190,"Data layer: Use a Repository pattern. The idea behind all this is that the origin of the data is transparent to the client, which does not care if the data is coming from memory, disk or the cloud, the only truth is that the information will arrive and will be gotten.",G,CLEAN,C,DATA,,CLEAN5,CLEAN4,4,Each layer has its own data model. Outer layers should not know any implementation detail about the inner layers.
126,"Every layer to have its own model that it works with, so the concrete details, such as views, do not depend on the specific details of the lower layer implementations.",G,CLEAN,GEN,,,CLEAN5,CLEAN4,4,Each layer has its own data model. Outer layers should not know any implementation detail about the inner layers.
253,"[On clean ark] It is a good practice for every layer to have its own model that it works with, so your concrete details, such as views, do not depend on the specific details of your lower layer implementations. This way, you won’t have to break unrelated code if you, for example, decide to change from one ORM to another. To make that possible, it is necessary to use object mappers in each layer.",G,CLEAN,GEN,DEP,,CLEAN5,CLEAN4,4,Each layer has its own data model. Outer layers should not know any implementation detail about the inner layers.
233,"[Hexagonal ark] The main objective of this architecture is to separate concerns and have the business logic isolated, through the implementation of Ports and Adapters",G,CLEAN,GEN,SEP,,CLEAN5,CLEAN4,4,Each layer has its own data model. Outer layers should not know any implementation detail about the inner layers.
187,"Presentation layer: Presenters in this layer are composed with interactors (use cases) that perform the job in a new thread outside the main android UI thread, and come back using a callback with the data that will be rendered in the view.",G,CLEAN,C,,,CLEAN4,CLEAN5,2,"Keep the UI thread as lightweight and isolated as possible (related to inversion of control, callback-based communication among components, intent-based communication)"
193,"Data transformation/composition: we can combine multiple Observables<T> without affecting the client, which makes our solution more scalable.",G,CLEAN,C,,,CLEAN4,CLEAN5,2,"Keep the UI thread as lightweight and isolated as possible (related to inversion of control, callback-based communication among components, intent-based communication)"