ID,RawPractice,Type,Theme,Component,Sub-theme,Sub-sub-theme,GuidelineID,NewGuidelineID,OccurrencyGuideline,WorkingGuidelines,GuidelineID,Guideline
148,"View layer had too many responsibilities. [...] This is a very simple example. In a real case scenario the REST API will probably not return the data like the view needs it. Therefore, the Activity will have to somehow transform or filter the data before showing it.",B,MVP,"M,V,P",RED,,MVP0,MVP1,9,Provide Views and Fragments with data which is ready to be displayed,,
154,"The DataManager is the brain of the architecture. It extensively uses RxJava operators to combine, filter and transform data retrieved from helper classes. The aim of the DataManager is to reduce the amount of work that Activities and Fragments have to do by providing data that is ready to display and won’t usually need any transformation.",G,MVP,M,RED,,"MVP0, MVP1",MVP1,9,Provide Views and Fragments with data which is ready to be displayed,,"(i) The ultimate goal of a well designed MVP model in Android is to reduce the amount of work that Activities and Fragments. This is achieved in the Model by providing data that is ready to display without any additional transformation. (ii) At the same time, it is important to keep under control size and complexity of the model, before it becomes too bloated and difficult to maintain."
157,Moving code from Activities and Fragments to the DataManager and helpers means that writing unit tests becomes easier.,G,MVP,"M,V",RED,,"MVP0, MVP1",MVP1,9,Provide Views and Fragments with data which is ready to be displayed,,
156,"The DataManager takes over responsibilities that were previously part of the view layer. Hence, it makes Activities and Fragments more lightweight.",G,MVP,M,RED,,"MVP0, MVP1",MVP1,9,Provide Views and Fragments with data which is ready to be displayed,,
158,"Clear separation of responsibilities and having the DataManager as the only point of interaction with the data layer, makes this architecture testfriendly. Helper classes or the DataManager can be easily mocked.",G,MVP,"M,V",SEP,,MVP6,MVP1,9,Provide Views and Fragments with data which is ready to be displayed,,
159,For large and very complex projects the DataManager can become too bloated and difficult to maintain.,B,MVP,M,COMPLEX,,MVP5,MVP1,9,Provide Views and Fragments with data which is ready to be displayed,,
163,"If the data manager is becoming bloated, we can mitigate this problem by moving some code to the presenters.",M,MVP,"M,P",COMPLEX,,MVP5,MVP1,9,Provide Views and Fragments with data which is ready to be displayed,,
164,Having a single data manager can still be an issue when the codebase becomes very large and complex. We haven’t reached the point where this is a real problem but we are aware that it could happen.,B,MVP,M,COMPLEX,,MVP5,MVP1,9,Provide Views and Fragments with data which is ready to be displayed,,
255,"[MVP + Managers] But we had this data manager class, which was already becoming bloated with multiple responsibilities. It was accessing the API, accessing the cache. It felt a bit like oh we got this data operation, let’s stick it in that data manager class. It’s messy. There was a data manager class with multiple responsibilities it was accessing the API and accessing the cache alongside preference helper classes. Despite splitting these out into a composer and user data manager, it was still bloated and unorganized. In the instance of the data manager, if we wanted to take the app offline in the future, how would we be able to accomplish that based on its current state?",B,MVP,M,COMPLEX,,MVP5,MVP1,9,Provide Views and Fragments with data which is ready to be displayed,,
177,"You may need the context to access shared preferences or resources, for example. But you shouldn’t do that in the presenter: you should access to resources in the view and to preferences in the model. By the way, the dependency inversion principle helps a lot in cases like this, when you need to decouple an object.",M,MVP,"M,V,P",,,MVP12,MVP2,5,Presenter should be Android/framework-independent.,,
119,Presenter does not depend on Android classes hence improves testability.,G,MVP,P,JAVA-ONLY,,MVP12,MVP2,5,Presenter should be Android/framework-independent.,,
130,"Don't create a lifecycle in presenter, otherwise your presenter will be tightly connected with the Android component where most have their own differences. This makes the presenter more dependent and highly rigid to modification.",B,MVP,P,,,MVP12,MVP2,5,Presenter should be Android/framework-independent.,,
162,"We can now easily write unit tests for the presenters by mocking the view layer. Before, this code was part of the view layer so we couldn’t unit test it. The whole architecture becomes very testfriendly.",G,MVP,P,test,,MVP12,MVP2,5,Presenter should be Android/framework-independent.,,
176,"In order to make the previous principle really effective (improving testability), make sure that presenter doesn’t depend on Android classes. Write the presenter using just Java dependencies for two reasons: firstly you are abstracting presenter from implementation details (Android framework) and consequently, you can write noninstrumented tests for the presenter (even without Robolectric), running tests faster on your local JVM and without an emulator.",G,MVP,P,JAVA-ONLY,,MVP12,MVP2,5,Presenter should be Android/framework-independent.,,
185,"Provide a cache for the Model to restore the View state. In my opinion, solving the “restore state” problem requires adapting a bit the app architecture. A great solution in line with this thoughts was proposed in this article. Basically, the author suggests caching network results using an interface like a Repository or anything with the aim to manage data, scoped to the application and not to the Activity (so that it can survive to orientation changes).",G,MVP,"M,V",CACHING,,MVP2,MVP3,5,App-scoped component for caching data coming from the M (survives orientation changes of the view),,
211,In conclusion I feel that the simplest way to work with data is to have an Activity/Fragment/View which owns a Presenter. That Presenter can request data from an app scoped Store which can either fetch new data or return cached data.,G,MVP,"M,P",,,MVP2,MVP3,5,App-scoped component for caching data coming from the M (survives orientation changes of the view),,
37,"Manage the low level networkign with an adhoc model, the service then puts the model with the presenter (at a higher level) and at the above level is the view",G,GEN,CONN,,,MVP2,MVP3,5,App-scoped component for caching data coming from the M (survives orientation changes of the view),,
19,[GOOD] Abstraction of data layer (it should be well encapsulated).,G,MVP,M,,,MVP2,MVP3,5,App-scoped component for caching data coming from the M (survives orientation changes of the view),,
209,Writing the storage layer: This is where our repository gets implemented. All the database specific code should come here.,G,MVP,M,RED,,MVP2,MVP3,5,App-scoped component for caching data coming from the M (survives orientation changes of the view),,
178,"When you are going to write a new feature, it is a good practice to write a contract at first step. The contract describes the communication between view and presenter, it helps you to design in a cleaner way the interaction.",G,MVP,"V,P",,,MVP4,MVP4,4,Clearly define the contract between View and Presenter (for each event in the View -> Action in the Presenter),,
180,"During the “contract design” phase, you must decide for each user event, what is the corresponding action and who the logic should belong to.",G,MVP,"V,P",,,MVP4,MVP4,4,Clearly define the contract between View and Presenter (for each event in the View -> Action in the Presenter),,
264,"[MVP] The ModelViewPresenter pattern brings with it a very good separation of concerns. While this is for sure a pro, when developing a small app or a prototype, this can seem like an overhead. To decrease the number of interfaces used, some developers remove the Contract interface class, and the interface for the Presenter.",G,MVP,"V,P",,,MVP4,MVP4,4,Clearly define the contract between View and Presenter (for each event in the View -> Action in the Presenter),,
268,"[MVP] To make the Presenter unit testable with JUnit, the View is abstracted and an interface for it used. The relationship between the Presenter and its corresponding View is defined in a Contract interface class, making the code more readable and the connection between the two easier to understand.",G,MVP,"V,P",,,MVP4,MVP4,4,Clearly define the contract between View and Presenter (for each event in the View -> Action in the Presenter),,
132,"Use cache a mechanism like LRUCache to retain the data, keep the presenter stateless, and let it recreate with the creation of an activity or fragment.",G,MVP,P,CACHING,,"MVP7, MVP13","MVP5, MVP8","4, 2","Presenter should be stateless. Presenter's lifecycle should follow the lifecycle of the View, but not replicating the complexity of Android's components lifecycles.",,
181,"Do not create Activitylifecyclestyle callbacks in the Presenter interface. In this way, the presenter would be coupled in particular with the Activity lifecycle. The presenter shouldn’t have a so complex lifecycle.",B,MVP,P,,,MVP7,MVP5,4,"Presenter's lifecycle should follow the lifecycle of the View, but not replicating the complexity of Android's components lifecycles.",,
184,"No. Do not retain the presenter. I don’t like this solution mainly because I think that presenter is not something we should persist, it is not a data class, to be clear.",B,MVP,P,,,MVP7,MVP5,4,"Presenter's lifecycle should follow the lifecycle of the View, but not replicating the complexity of Android's components lifecycles.",,
182,Presenter has a 1to1 relation with the view. The presenter doesn’t make sense without a view. It comes with the view and goes when the view is destroyed. It manages one view at a time.,G,MVP,"V,P",,,MVP7,MVP5,4,"Presenter's lifecycle should follow the lifecycle of the View, but not replicating the complexity of Android's components lifecycles.",,
145,"In MVP, as projects grow, the presenter can become a huge class with a lot of methods, making it hard to maintain and understand. That happens because it is responsible for a lot of stuff: it has to handle UI Events, UI logic, business logic, networking and database queries. That violates the Single Responsibility Principle.",B,MVP,P,COMPLEX,,MVP10,MVP6,3,Presenter as bloat class with too many responsibilities.,,
241,"[MVP] The elephant in the room here is the presenter. It’s a god object. It deals with the models, it sends the data to the view, it holds the business logic (business logic are those gears :) ), and it goes to the database and Internet, fetches sensor data, etc. So yeah, better, but it could get way more better.",B,MVP,P,COMPLEX,,MVP10,MVP6,3,Presenter as bloat class with too many responsibilities.,,
265,"[MVP] One of the pitfalls of MVP appears when moving the UI logic to the Presenter: this becomes now an allknowing class, with thousands of lines of code. To solve this, split the code even more and remember to create classes that have only one responsibility and are unit testable.",M,MVP,P,COMPLEX,,MVP10,MVP6,3,Presenter as bloat class with too many responsibilities.,,
125,"The Presenter depends on the View interface and not directly on the Activity: in this way, we succeed in decoupling the presenter from the view implementation respecting the D of the SOLID principles. We can replace the concrete view without changing a line of code of the presenter. Furthermore, we can easily unittest presenter by creating a mock view.",G,MVP,"V,P",,,MVP11,MVP7,2,Presenter depends on View (not on Activities),,
179,"The View contract: Like I said before, the view is implemented by an Activity (or a Fragment). The presenter must depend on the View interface and not directly on the Activity.",G,MVP,"V,P",,,MVP11,MVP7,2,Presenter depends on View (not on Activities),,
183,"Do not save the state inside the presenter. I mean using a Bundle. I’m not saying that the presenter should be stateless because I’d be lying. In the use case I described before, for instance, the presenter should at least have the page number/offset somewhere.",B,MVP,P,,,MVP13,MVP5,2,Presenter should be stateless.,,
165,"In MVP (or at least, in our vision of MVP) it is only the view that holds the current state of itself. Think about a screen that shows a “Loading….” spinner: the Presenter sets such spinner to visible, and once the requested data is loaded the spinner is hidden. But what happens if, in the meantime, the presenter wants to know if the spinner is visible? It can either privately keep this information or query the view for it. Now, what if the screen has more and more features? Is the presenter going to keep the current “state” of every single button, view, list along with the business logic of the app? Well, if yes: the complexity to keep synchronised what the view is showing and what the presenter knows about the view will easily explode. Because an Android View is a very transient object, that could be destroyed at any given moment, and because the View is the state, it is hard to keep track and recreate exactly the last screen visualized to the user.",B,MVP,"V,P",,,MVP14,MVP8,2,Views are passive and should always manage and expose only their state.,,
175,"One of the biggest problems of Android is that views (Activities, Fragments,…) aren’t easy to test because of the framework complexity. To solve this problem, you should implement the Passive View pattern. The implementation of this pattern reduces the behavior of the view to the absolute minimum by using a controller, in our case, the presenter. For example, if you have a username/password form and a “submit” button, you don’t write the validation logic inside the view but inside the presenter. Your view should just collect the username and password and send them to the presenter.",M,MVP,"V,P",no logic in view,,MVP14,MVP8,2,Views are passive and should always manage and expose only their state.,,
4,Put the business logic in the presenters and not in the views/activities,G,GEN,DEV,,,MVP3,MVP9,2,Business logic in the Presenter,,
35,Put most of the logic in the Presenter,G,MVP,P,,,MVP3,MVP9,2,Business logic in the Presenter,,
267,"[MVP] Presenter: In the implementation of the constructor, the Presenter will call the setPresenter method of the View. This can be simplified when using a dependency injection framework that allows the injection of the Presenters in the corresponding views, reducing the coupling of the classes.",G,MVP,P,,,MVP9,MVP10,2,Inject the dependency to the Presenter into the View when instantiating the Presenter (less coupling and less null checks),,
131,"Introducing a method in presenter which accepts the view reference requires null checks at many places, so avoid it if you can and instead use constructor.",B,MVP,P,,,MVP9,MVP10,2,Inject the dependency to the Presenter into the View when instantiating the Presenter (less coupling and less null checks),,
215,"How does a “ChildPresenter” communicate with its “ParentPresenter”? From my point of view such ParentChild relations are a code smell, because they introduce a direct coupling between both Parent and Child, which leads to code that is hard to read, hard to maintain, where changing requirement affects a lot of components (hence it’s a virtually impossible task in large systems) and last but not least introduces shared state that is hard to predict and even harder to reproduce and debug.",B,GEN,DEV,,,MVP15,MVP11,1,Do not let Presenters communicate with each other.,,
109,A comment on MVP (Model View Presenter) from previous example: I found tricky to avoid leaks due to activities and fragments being recreated so I used a poor man solution: retain fragments.,G,MVP,P,,,MVP8,MVP12,1,"If necessary, retain fragments for avoiding memory leaks due to configuration changes in the activities ",,