ID,RawPractice,Type,Theme,Component,Activity,Fragment,BroadcastReceiver,Service,ContentProvider,Manifest,LayoutXML,JetPack
1,Do not do too much in activities and fragments,B,GEN,,x,x,,,,,,
2,"Stick to a precise architecture, e.g. MVP and MVVM",G,GEN,,,,,,,,,
3,"Do not use concrete classes but interfaces, which are more easy to change",M,GEN,,,,,,,,,
4,Put the business logic in the presenters and not in the views/activities,G,GEN,,,,,,,,,
5,"When starting a new project, use directly MVP",G,GEN,,,,,,,,,
6,When developing a base activities make sure that it can be easy be used by inherited classes,G,GEN,,x,,,,,,,
7,Divide core logic from UI,G,GEN,,,,,,,,,
8,"Too many callbacks, such as 2 depth levels of callbacks are hard to read",G,GEN,,,,,,,,,
9,"We did not separate common functionality in base fragments and activities, but had one different for each, reducing maintainability.",B,GEN,,x,x,,,,,,
10,Adhere to the KISS principle. ,G,GEN,,,,,,,,,
11,"when talking about module, we have a feature A and feature B, it is good to separate into two submodules.",G,GEN,,,,,,,,,
12,"DataStorage, if put into a dedicated submodule it is easier to maintain.",G,GEN,,,,,,,,,
13,Variable and function names should be meaningful.,G,GEN,,,,,,,,,
14,Separate model from the view,G,MVP,"M,V",,,,,,,,
15,"Separate the code into the components of MVP, MVC",G,GEN,,,,,,,,,
16,Core logic should be testable,G,GEN,,,,,,,,,
17,Use continuous integration and deployment,G,GEN,,,,,,,,,
18,[GOOD] Separation of responsibility: one component should do only one thing good,G,GEN,,,,,,,,,
19,[GOOD] Abstraction of data layer (it should be well encapsulated).,G,MVP,MVP,,,,,,,,
20,"[GOOD] Network connectivity should be handled with care, local caching through error handling.",G,GEN,,,,,,,,,
21,"[GOOD] Power management, graceful failing, retry when server fails, incremental pinging when server is unresponsive, bundled updates of various app to avoid constant throttling in background.",G,GEN,,,,,,,,,
22,"[BAD] Not using the compatibility library (makes new features backwards compatible), called “compat library”.",B,GEN,,,,,,,,,
23,[BAD] God object,B,GEN,,,,,,,,,
24,[BAD] No clear separation of responsibility,B,GEN,,,,,,,,,
25,[BAD] Not using a dedicated business logic layer,B,GEN,,,,,,,,,
26,[BAD] Not using a dedicated data holding layer,B,GEN,,,,,,,,,
27,[BAD] Mixing code and UI,B,GEN,,,,,,,,,
28,[BAD] Singleton,B,GEN,,,,,,,,,
29,"[BAD] Directory/file structure should be tidy: if there is a mix in the folders, there is a mix also in the code, similar stuff should go in the same folder/subfolders.",B,GEN,,,,,,,,,
30,"[BAD] Event driven programming, if no interfaces are used bad, or do not provide basic functions in base classes (also to avoid code duplicates).",B,GEN,,,,,,,,,
31,[BAD] Naming patterns should be used consistently and with sense.,B,GEN,,,,,,,,,
32,Do not throw everything in an activity,G,GEN,,x,,,,,,,
33,Use Dagger,G,GEN,,,,,,,,,
34,"Use a separate model for the network, then create a model internal to the app",G,GEN,,,,,,,,,
37,"Manage the low level networkign with an adhoc model, the service then puts the model with the presenter (at a higher level) and at the above level is the view",G,GEN,,,,,,,,,
35,Put most of the logic in the Presenter,G,MVP,,,,,,,,,
36,"Put the Presenter lisening to the tables, and the Presenter then updates the view",G,MVP,,,,,,,,,
38,Do not put logic in the views,B,GEN,,x,x,,,,,,
39,"Do not put logic in the Presenter, as you cannot do unit testing",B,GEN,,,,,,,,,
40,Use Reactive minfdully in order to avoid resource leaks,B,GEN,,,,,,,,,
41,Use a library to manage images,G,GEN,,,,,,,,,
42,Architecture needs to be in line with the project,G,GEN,,,,,,,,,
43,Avoid God Classes by creating a superactivity,B,GEN,,x,,,,,,,
44,Put all logic in presenter,G,GEN,,,,,,,,,
45,Use a tidy folder structure and file layout,G,GEN,,,,,,,,,
46,No more than 1.000 lines per component\class,B,GEN,,,,,,,,,
47,Methods should be kept small,B,GEN,,,,,,,,,
48,Respect separation of concern at method level,G,GEN,,,,,,,,,
49,Do not use too many small activities. The purpose of each activity should be easy to be explained,B,GEN,,x,,,,,,,
50,Background tasks should not run forever,B,GEN,,,,,x,,,,
51,"the application structure consists of a set of monolithic classes. These classes group almost all project code in a few classes, thus this application does not present a wellmodularized architecture.",B,GEN,,,,,,,,,
55,3) We also analysed the package organization of each selected application in order to identify whether the separation into architectural components as reflected in the package structure.,G,GEN,,,,,,,,,
52,"2) we also found some violations to the MVC pattern. Although most of these violations do not represent a clear threat to the evolution of the architecture of the existing applications, they need to be monitored in order to avoid future maintenance difficulties",B,MVC,,,,,,,,,
53,"2.1) ModeltoView violation. The first found scenario was a violation of the independence of the model component, where model classes have direct calls to classes of the View component.",B,MVC,M,,,,,,,,
54,"2.2) ModeltoController violation. Similar to the previous kind of violation, this second case implies the rupture of independence of the model component, since this component is dependent of the controller component.",B,MVC,M,,,,,,,,
56,"3.1) many applications grouped their classes based on the MVC components, creating a separated package for each architectural component (model, view or controller)",G,GEN,,,,,,,,,
57,"3.2) On the other hand, some applications have grouped their classes according to the business concern.",G,GEN,,,,,,,,,
82,Activities and Fragments should only contain logic that handles UI and operating system interactions.,G,GEN,,x,x,,,,,,
58,The gain with the adoption of this pattern [MultipleView Layout] is directly related to the treatment of the variability of multiple screens and indirectly to reuse screens.,,,,,,,,,,,
59,"The Adapter pattern, for example, was commonly used to adapt existing Android classes to create customized views.",,,,,,,,,,,
60,"Permission use within apps is consistent, meaning that any component of an app that has a permission must be declared also at the app level. This constraint is defined for each application group.",G,GEN,,,,,,,,,
61,Explicit intent connectors should reference valid targets.,G,GEN,,,,,,,,,
62,All implicit intents are attached to the global implicit intent bus.,G,GEN,,,,,,,,,
63,Activities and services that are not exported by an app are not connected to other apps.,G,GEN,,,,,,,,,
64,"Parts of code integrated into single Activity cannot be reused, methods can only be copied to another Activity making the redundant code. Any additional View and action complicates the Activity. A modification of one action repeating on several screens requires modification in all related Activities (assuming one Activity per screen). Activity can contain the implementation of very different actions non related to each other, this can make the Activity very complex, unreadable and incomprehensible. Activity is kept in memory while the application is running, thereby a very big Activity affects performance. Finally, the modification in the user interface and application logic can lead to the need of full redevelopment of all Activities.",B,GEN,,x,x,,,,,,
65,The coupling between components should be weak to avoid the modification of other components if one is modified.,G,GEN,,,,,,,,,
66,"Modules should be reusable [17][22]. A mobile phone has a limited memory, therefore the creation of unnecessary objects should be avoided.",G,GEN,,,,,,,,,
67,Objects remaining in the memory should be lightweight [19]. Modification in user interface or in navigation logic should involve the minimum modification of the application.,G,GEN,,,,,,,,,
68,To keep components loosely coupled it is recommended to ensure communication between Controllers and Activity via interfaces.,G,GEN,,,,,,,,,
69,Fragments should rarely have a callback to parent Fragments but if necessary the callback can be implemented with interfaces.,M,GEN,,,,,,,,,
70,Developer should avoid high hierarchy between Fragments within a single Activity as parent Fragment is linked to the child Fragments. Activities make components more independent and simplifies the Fragment management.,G,GEN,,,,,,,,,
71,"Android does not directly support a general reuse model, since Android fragments must have a UI. To reuse common functionality, that does not have its own UI, a reuse model is required that is tailored to activities.",G,GEN,,,,,,,,,
72,"To provide a custom work flow for concrete apps, the SPL [Software Product Line] should support refinements of the intents connecting activities. This means that the SPL should enable the substitution of base activities with specialized activities or calls to external services (e.g., the Android gallery, the camera or other apps).",,,,,,,,,,,
73,"In Android, uservisible settings are statically defined in an XML (eXtensible Markup Language) file which does not provide a visibility flag. Therefore, all apps in the SPL would have the same preference entries. In order to provide variability of preference entries, an Android app SPL should support custom preference entries for each concrete app.",,,,,,,,,,,
74,Many apps share a common domain or business process while each app should be tailored to the needs of a different target group.,,,,,,,,,,,
75,"SPLs usually provide a feature model defining which features are contained in each concrete product. However, product flavors, the static configuration mechanisms offered by Android, do not support modularization of the feature selection and feature configuration.",,,,,,,,,,,
76,architecture based support for variability in SPLs are: V1: Inheritance is used when a feature needs to be implemented differently for a product or a product should extend a type defined in the core assets. V2: Extensions and extension points are used when parts can be extended with additional behavior. Design Patterns [14] are a common way to build extensions points into an SPL [12]. V3: Parametrization is used when parameters can be referenced inside the core asset code and instantiated with a concrete value in the concrete products. A parameter has an initial value which can be adjusted by the concrete products. V4: Configuration is used to connect modules and components to each other. Configuration is the process of assembling a product by selecting and connecting modules and components out of the core assets. V5: Generation is used when a higher level language can be applied to define concrete component properties.,,,,,,,,,,,
77,"Allowed Communication: Let E be a set of all exported components, and c1 and c2 be two arbitrary components in the system. We say that c1 can communicate with c2, if either both components belong to the same app or c2 is an exported component and c1 is granted the permissions enforced by c2: communicate(c1, c2) ≡ (appc1 = appc2) ∨ (c2 ∈ E ∧ enforcedc2 ⊆ grantedc1)",,,,,,,,,,,
78,"Required Permission: Let c1 be a compo nent, and usedc1 be a set of permissions directly used by component c1.",,,,,,,,,,,
79,"Privilege Escalation: Let p be a permis sion, cm be a component that does not hold p, and cv be a component that holds and uses p but does not enforce (check) the components that may be using its services also hold p. In the privilege escalation attack, cm is able to indirectly obtain p by interacting with cv. communicate(cm,cv)∧p ∈ usedcv ∧p ̸∈ grantedcm ∧ p ̸∈ enforcedcv",,,,,,,,,,,
80,"1) Broadcast Receiver is best to be clearly defined as a connector, discouraging developers of including applicationspecific logic within such a module that by design should behave as a gateway to other components, a responsibil ity advocated to assign to connectors in the architecture literature (Mehta et al., 2000). Essentially, the Broadcast Receiver in Android by itself can be a complicated building block, supporting three dif ferent types of broadcast Intents, that incorporating application specific logic into may make it very hard to understand. In fact, the phenomenon, where a component acts also as a connector, is referred to as Connector Envy (Garcia et al., 2009), an architectural decay instance that results in bloated components, reduces efficiency by increasing each affected component’s memory footprint, and renders such components more complex and less maintainable. (Section 6.4)",B,GEN,,,,,,,,,
81,"2) Modelviewcontroller antipattern. Another poor separation of concerns occurs due to Android’s design that breaks the ModelViewController (MVC) architectural pattern (Krasner et al., 1988; Taylor et al., 2009). In that pattern, a View component provides graphical depictions of information; a Model component contains information to be depicted; and a Controller component maintains consistency between the Model and View. In Android, a Content Provider acts as a Model; the responsibilities of the View and Controller are integrated into one component, an Activity (cf. Section 4.1). This violates the singleresponsibility design principle (Gamma et al., 1994), resulting in a poor separation of concerns that breaks the MVC pattern (Sokolova et al., 2013). This design decision results in an architectural antipattern (Brown et al., 1998), which is a recurring set of architectural elements that together negatively affects the architecture of a system, and renders the system more complex and less maintainable. For example, testing the operations of the View and Controller in Android cannot be done separately Discourages development of “bloated” Activity components that suffer from increased memory footprints and de creased efficiency.",B,GEN,,,,,,,,,
83,Drive your UI from a model,G,GEN,,,,,,,,,
85,"Note: If you're already using a library like RxJava or Agera, you can continue using them instead of LiveData. When you use libraries and approaches like these, however, make sure you handle your app's lifecycle properly. In particular, make sure to pause your data streams when the related LifecycleOwner is stopped and to destroy these streams when the related LifecycleOwner is destroyed. You can also add the android.arch.lifecycle:reactivestreams artifact to use LiveData with another reactive streams library, such as RxJava2.",G,GEN,,,,,,,,,
84,"Implementing ViewModel might involve directly calling the Webservice to fetch the data and assign this data to our LiveData object. This design works, but by using it, our app becomes more and more difficult to maintain as it grows. Additionally, the scope of a ViewModel is tied to an Activity or Fragment lifecycle, which means that the data from the Webservice is lost when the associated UI object's lifecycle ends. This behavior creates an undesirable user experience.",B,MVVM,VM,x,x,,,,,,x
86,"The UserRepository class above needs an instance of Webservice to fetch the user's data. It could simply create the instance, but to do that, it also needs to know the dependencies of the Webservice class. Additionally, UserRepository is probably not the only class that needs a Webservice. This situation requires us to duplicate code, as each class that needs a reference to Webservice needs to know how to construct it and its dependencies. If each class creates a new WebService, our app could become very resource heavy. You can use the following design patterns to address this problem: - Dependency injection (DI): Dependency injection allows classes to define their dependencies without constructing them. At runtime, another class is responsible for providing these dependencies. We recommend the Dagger 2 library for implementing dependency injection in Android apps. Dagger 2 automatically constructs objects by walking the dependency tree, and it provides compiletime guarantees on dependencies. - Service locator: The service locator pattern provides a registry where classes can obtain their dependencies instead of constructing them. - It's easier to implement a service registry than use DI, so if you aren't familiar with DI, use the service locator pattern instead. - These patterns allow you to scale your code because they provide clear patterns for managing dependencies without duplicating code or adding complexity. Furthermore, these patterns allow you to quickly switch between test and production datafetching implementations. Our example app uses Dagger 2 to manage the Webservice object's dependencies.",M,GEN,,,,,,,,,
91,"Avoid designating your app's entry points—such as activities, services, and broadcast receivers—as sources of data. Instead, they should only coordinate with other components to retrieve the subset of data that is relevant to that entry point. Each app component is rather shortlived, depending on the user's interaction with their device and the overall current health of the system.",M,GEN,,x,x,x,,,,,
87,"The UserRepository implementation abstracts the call to the Webservice object, but because it relies on only one data source, it's not very flexible. The key problem with the UserRepository implementation is that after it fetches data from our backend, it doesn't store that data anywhere. Therefore, if the user leaves the UserProfileFragment, then returns to it, our app must refetch the data, even if it hasn't changed. This design is suboptimal for the following reasons: - It wastes valuable network bandwidth. - It forces the user to wait for the new query to complete. - To address these shortcomings, we add a new data source to our UserRepository, which caches the User objects in memory",,,,,,,,,,,
88,"By relying on our current implementation in this situation, we need to fetch the data again from the network. This refetching process isn't just a bad user experience; it's also wasteful because it consumes valuable mobile data. You could fix this issue by caching the web requests, but that creates a key new problem: What happens if the same user data shows up from another type of request, such as fetching a list of friends? The app would show inconsistent data, which is confusing at best. The proper way to handle this situation is to use a persistent model. This is where the Room persistence library comes to the rescue.",M,MVVM,M,,,,,,,,x
89,"Using this model, the database serves as the single source of truth, and other parts of the app access it using our UserRepository. Regardless of whether you use a disk cache, we recommend that your repository designate a data source as the single source of truth for the rest of your app.",G,MVVM,M,,,,,,,,x
90,"Test each component. In the separation of concerns section, we mentioned that one key benefit of following this principle is testability. The following list shows how to test each code module from our extended example: - User interface and interactions: Use an Android UI instrumentation test. The best way to create this test is to use the Espresso library. You can create the fragment and provide it a mock UserProfileViewModel. Because the fragment communicates only with the UserProfileViewModel, mocking this one class is sufficient to fully test your app's UI. - Webservice: In these tests, avoid making network calls to your backend. It's important for all tests, especially webbased ones, to be independent from the outside world. - Testing Artifacts: Architecture Components provides a maven artifact to control its background threads. The android.arch.core:coretesting artifact contains the following JUnit rules: - InstantTaskExecutorRule: Use this rule to instantly execute any background operation on the calling thread. - CountingTaskExecutorRule: Use this rule to wait on background operations of Architecture Components. You can also associate this rule with Espresso as an idling resource.- ViewModel: You can test the UserProfileViewModel class using a JUnit test. You only need to mock one class, UserRepository. - UserRepository: You can test the UserRepository using a JUnit test, as well. You need to mock the Webservice and the UserDao. In these tests, verify the following behavior: - The repository makes the correct web service calls. - The repository saves results into the database. - The repository doesn't make unnecessary requests if the data is cached and up to date. - Because both Webservice and UserDao are interfaces, you can mock them or create fake implementations for more complex test cases. - UserDao: Test DAO classes using instrumentation tests. Because these instrumentation tests don't require any UI components, they run quickly. - For each test, create an inmemory database to ensure that the test doesn't have any side effects, such as changing the database files on disk.",,,,,,,,,,,
92,"Create welldefined boundaries of responsibility between various modules of your app. For example, don't spread the code that loads data from the network across multiple classes or packages in your code base. Similarly, don't define multiple unrelated responsibilities—such as data caching and data binding—into the same class.",G,GEN,,,,,,,,,
93,"Expose as little as possible from each module. Don't be tempted to create just that one shortcut that exposes an internal implementation detail from one module. You might gain a bit of time in the short term, but you then incur technical debt many times over as your codebase evolves.",G,GEN,,,,,,,,,
94,"Consider how to make each module testable in isolation. For example, having a welldefined API for fetching data from the network makes it easier to test the module that persists that data in a local database. If, instead, you mix the logic from these two modules in one place, or distribute your networking code across your entire code base, it becomes much more difficult—if not impossible—to test.",G,GEN,,,,,,,,,
95,"Focus on the unique core of your app so it stands out from other apps. Don't reinvent the wheel by writing the same boilerplate code again and again. Instead, focus your time and energy on what makes your app unique, and let the Android Architecture Components and other recommended libraries handle the repetitive boilerplate.",G,GEN,,,,,,,,,
96,"Persist as much relevant and fresh data as possible. That way, users can enjoy your app's functionality even when their device is in offline mode. Remember that not all of your users enjoy constant, highspeed connectivity.",G,GEN,,,,,,,,,
97,"Assign one data source to be the single source of truth. Whenever your app needs to access this piece of data, it should always originate from this single source of truth.",G,GEN,,,,,,,,,
99,It’s recommended to use Dependency Injection (cough….Dagger….cough) or Service Locator pattern to manage dependencies between the components.,G,GEN,,,,,,,,,
98,"Keep Activity and Fragments lean by only maintaining UI related code like click listeners, etc. And the ViewModel provides the data required by the UI controllers like Activity and Fragments, this helps in surviving configuration change. While ViewModel gets the data from Repository which acts as single source of truth for data, that means whenever your app requires data, it always comes from Repository. Now Repository decides if the data is to be fetched from local database using Room or from web service using Retrofit.",,,,,,,,,,,x
101,"Remember, your UI should always reflect based on the data in the database.",G,GEN,,,,,,,,,
100,"Most modern Android apps maintain a synchronization between local database and the web service, this is super useful for users which helps in using the app even if the device is offline. This is something which users have started to nowadays expect in apps. It [the model] states to first fetch the data from local database; if the data doesn’t exist then make the required network call based upon the “should fetch” condition and then save the fetched data into the local database on response.",G,MVVM,M,,,,,,,,
103,"Having DI framework is not a must, you can live without it, but right setup of DI can really make your life easier. There are several libraries which offer ready solutions (e.g. Dagger, Roboguice, Toothpick). You can decide which one will fit best in your project, considering performance and usability. With dependency injection you don’t have to care so much about things like e.g. object creation, passing references, implementing singleton pattern.",G,GEN,,,,,,,,,
102,Interesting potential quote: No architecture is perfect for every usecase and Architecture Guidelines are just recommendations. Hence feel free to use whatever suites your usecase.,,,,,,,,,,,
104,"I think it is a good practice to wrap libraries with a layer of abstraction, this way you can avoid dependencies from particular library implementation inside your business logic. Also if you decide to change a library to a different one, you won’t have to do refactoring in the entire project, just inside a single repository. It is not necessary to use this pattern for everything, only for libraries which you are not confident you will be using in the future.",G,GEN,,,,,,,,,
105,"Separating project into a few modules should give you some profits. You can have abstract layers physically located in different modules, each module has its own build configuration, so you can customize dependencies for each of them. For example UI module doesn’t have to see database or network models, and low level modules don’t have to access libraries for animations, UI binding etc. With Android Gradle Plugin 3.0 or higher, modularization also increases building speed and makes solid fundaments for developing Instant Apps. Keep in mind, that modularization will be easy to achieve and low at cost at the beginning of project development, but when project is mature it will require much more effort.",G,GEN,,,,,,,,,
106,"Feature switching: This is not really something that you must have, but in some cases it can be useful. Feature switching basically allows you to configure set of features/screens which should be enabled in the app, this could be done via local configuration or remotely (e.g Firebase Remote Config). I especially recommend to have remote feature switching if your application contains functionality dependent on external web services. If external API fails, dependent features in your app will stop working as well. In such situation you should disable broken feature ASAP to avoid annoying users. If you have a remote configuration setup you can just disable given feature in remote console, until the API starts working again.",G,GEN,,,,,,,,,
111,Code/package organization is one of the key factors of a good architecture: package structure is the very first thing encountered by a programmer when browsing source code. Everything flows from it. Everything depends on it.,G,GEN,,,,,,,,,
107,"Interesting comment: The question is, should you always follow architecture guidelines or can you sometimes make exceptions if necessary ? The answer is up to you. The main goal of having defined architecture is to have order in the project and consistent way of doing things.",,,,,,,,,,,
108,The view model isolates the view from the model classes and allows the model to evolve independently of the view.,G,MVVM,M,,,,,,,,
109,A comment on MVP (Model View Presenter) from previous example: I found tricky to avoid leaks due to activities and fragments being recreated so I used a poor man solution: retain fragments.,G,MVP,P,x,x,,,,,,
110,"Overall Error/Exception Handling should be taken care at design and not at implementention level, and in my opinion, one of the biggest mistakes we make as developers (lesson learned). That is why it is important to have a framework in place for this purpose.",,,,,,,,,,,
112,"My second tip is to have a core module which will have these main responsitilities: * Handle global dependency injection. * Contain extension functions. * Contain the main framework abstractions. * Initiate in the main application common 3rd party libraries like Analytics, Crash Reporting, etc.",G,GEN,,,,,,,,,
115,Minimize framework (android) dependencies in your project as much as you can.,G,GEN,,,,,,,,,
113,"My third tip is not at codebase level, but it might be helpful to add code ownership if we are working with feature teams, which is a win in growing organizations where many developers are working on the same codebase.",,,,,,,,,,,
114,Make sure threading is not the only reason to introduce it [ RxJava] in your codebase.,,,,,,,,,,,
116,Dagger2 is used to avoid detailcomplicated boilerplate code of connecting architecture elements one to another.,G,GEN,,,,,,,,,
118,"Another important thing is different entities for each layer of application. As dependency inversion principle works in the other way works additional fields decreasing. The purpose of different entities for each layer is to reduce the amount of information inner layer may depend on. E.g., you don’t need api version at your entity in domain and presentation layers of your application, you only need this property in data layers.",G,GEN,,,,,,,,,
117,"Just a few principles(S O L I D) will allow us to decouple data fetching and handling processes of our application, build interchangeable views and keep their interfaces clean and simple, with keeping solid abstraction level from frameworks and data layer implementations.",,,,,,,,,,,
123,By injecting mock implementations of respective dependencies to separated classes can make testing much easier.,G,GEN,,,,,,,,,
119,Presenter does not depend on Android classes hence improves testability.,G,MVP,P,,,,,,,,
120,"Business logic shouldn’t know where the data comes from. Act locally, but sync globally.",G,CLEAN,B,,,,,,,,
121,"It’s all neatly separated by module level, package level and class level. So Single Responsibility Principle and Separation of Concern should be satisfied.",,,,,,,,,,,
122,Business logic doesn’t touch the Android directly anymore and this should result in a decoupled codebase.,G,CLEAN,"B,F",,,,,,,,
134,"Observing changes to data across multiple components of your app can create explicit, rigid dependency paths between the components. This makes testing and debugging, among other things, difficult. To avoid these problems, use LiveData, which is a lifecycle library class for data observation.",B,GEN,,,,,,,,,
124,"No compulsion to use Presenters to handle presentation logic, we could say that Clean architecture is “frontend” agnostic – meaning we can use MVP, MVVM or anything else on top of it.",G,CLEAN,F,,,,,,,,
125,"The Presenter depends on the View interface and not directly on the Activity: in this way, we succeed in decoupling the presenter from the view implementation respecting the D of the SOLID principles. We can replace the concrete view without changing a line of code of the presenter. Furthermore, we can easily unittest presenter by creating a mock view.",G,MVP,"V,P",,,,,,,,
126,"Every layer to have its own model that it works with, so the concrete details, such as views, do not depend on the specific details of the lower layer implementations.",G,CLEAN,,,,,,,,,
127,Instead of using callbacks to communicate between layers we can use the power of RxJava to provide the data upstream and let it handle thread scheduling for us. Each of the inner layers can transform the data in a way the outer layer can understand it.,G,CLEAN,,,,,,,,,
128,Allows changing the implementation of any outer layer without having to make a lot of changes in our codebase and fulfills the Extendability requirement.,,,,,,,,,,,
129,The practise of defining the MVP contract [https://github.com/googlesamples/androidarchitecture/blob/todomvpclean/todoapp/app/src/main/java/com/example/android/architecture/blueprints/todoapp/taskdetail/TaskDetailContract.java] before starting working on a feature indirectly helps android devs in the same squad to efficiently define areas of responsibilities among themselves.,,,,,,,,,,,
130,"Don't create a lifecycle in presenter, otherwise your presenter will be tightly connected with the Android component where most have their own differences. This makes the presenter more dependent and highly rigid to modification.",B,MVP,P,,,,,,,,
131,"Introducing a method in presenter which accepts the view reference requires null checks at many places, so avoid it if you can and instead use constructor.",B,MVP,P,,,,,,,,
132,"Use cache a mechanism like LRUCache to retain the data, keep the presenter stateless, and let it recreate with the creation of an activity or fragment.",G,MVP,P,,,,,,,,
133,Adhere to SOLID principles,,,,,,,,,,,
137,"A common pattern is to implement the actions of the dependent components in the lifecycle methods of activities and fragments. However, once you have multiple components, using this pattern leads to poor code organization and a proliferation of errors, such as possible race conditions. Lifecycleaware components perform actions in response to a change in the lifecycle status of another component. For example, a listener could start and stop itself in response to an activity starting and stopping. This results in code that is better organized, usually shorter, and always easier to maintain.",M,GEN,,x,x,,,,,,
135,"When you pass data through the layers of your app architecture from a Room database to your UI, that data has to be LiveData in all layers: All the data that Room returns to the Repository, and the Repository then passes to the ViewModel, must be LiveData. You can then create an observer in the activity that observes the data in the ViewModel.",,MVVM,,,,,,,,,
136,"Never pass context into ViewModel instances. Do not store Activity, Fragment, or View instances or their Context in the ViewModel. For example, an Activity can be destroyed and created many times during the lifecycle of a ViewModel, such as when the device is rotated. If you store a reference to the Activity in the ViewModel, you end up with references that point to the destroyed Activity. This is a memory leak. If you need the application context, use AndroidViewModel instead of ViewModel.",B,MVVM,,,,,,,,,x
138,"If the app isn't designed with care, it can request data that it doesn't need, which places a performance burden on the device, and on the network. If the data is stored or synchronized with a remote database, this can also slow the app and waste the user's data plan. The paging library addresses issues with existing solutions.",G,GEN,,,,,,,,,
139,Use a single activity for the whole flow,G,GEN,,x,,,,,,,
141,"[A Component] Has a single, well defined responsibility. The most important property of a Component is it should do just one thing. Nearly all Components in our app are currently about 100 –120 lines. When a Component starts getting bigger, we break it into more Components.",G,GEN,,,,,,,,,
140,Components can contain both UI and business logic,,,,,,,,,,,
142,"Components have explicitly defined inputs. A component takes all its inputs via the constructor. Specifying, the necessary inputs in the constructor ensures some compile time safety by guaranteeing that we have all values available before creating the Component. Another advantage of explicit inputs is that during testing we can mock these dependencies easily and test the component in isolation.",G,GEN,,,,,,,,,
144,"No more jumping between callbacks. In this example app, coroutines also completely removed the need of using RxJava. Functions with suspendable points are easier to read and understand than some RxJava operator chains — these chains can quickly become too functional (Having said that, I don’t think that RxJava can be replaced with coroutines in every use case. Observables give us a different kind of expressiveness that can not be mapped one to one to suspendable functions. In particular once constructed observable operator chain allow many events to flow through it, while a suspendable point resumes only once per invocation)",M,GEN,,,,,,,,,
143,"Event Driven Architecture some how... this type of architecture defines the communication between the components in the system / application through Events, where an event (broadcast) is fired by someone, and all who is interested in this event will listen to this event (broadcast) and every one takes action according to there own implementation. [...] one of the well known issues in Event Driven Architecture is ... it can get out of hand so easily. Applications go too big that it will be hard to track who triggered the event (broadcast) that caused the mess, so a similar Architecture came with a solution. [Solution: Message driven architecture:] instead of firing an event to all the application components, we trigger an event for a specific component only, And this event is now called a Message, since it is sent to specific components, and not to all components.",M,CUSTOM,C,,,,,,,,
147,"I started to use interfaces for linking the modules together. That way, they can’t access methods other than the ones declared on the interface. This protects the structure and helps defining a clear responsibility for each module, avoiding developer mistakes like putting the logic in the wrong place.",G,GEN,,,,,,,,,
145,"In MVP, as projects grow, the presenter can become a huge class with a lot of methods, making it hard to maintain and understand. That happens because it is responsible for a lot of stuff: it has to handle UI Events, UI logic, business logic, networking and database queries. That violates the Single Responsibility Principle.",B,MVP,P,,,,,,,,
146,"I started a new Android project and decided to use MVP + Interactor (or VIPE, if you will). That allowed me to move some responsibility from the presenter to the Interactor. Leaving the presenter with UI events handling and preparing the data that comes from the Interactor to be displayed on the View. Then, the Interactor is only responsible for the business logic and fetching data from DBs or APIs.",G,CUSTOM,C,,,,,,,,
150,Activities and Fragments become very large and difficult to maintain,B,GEN,,x,x,,,,,,
148,"View layer had too many responsibilities. [...] This is a very simple example. In a real case scenario the REST API will probably not return the data like the view needs it. Therefore, the Activity will have to somehow transform or filter the data before showing it.",B,MVP,"M,V,P",x,,,,,,,
149,"Another common case is when the loadPosts() method takes a parameter that needs to be fetched from somewhere else, for example an email address provided by the Play Services SDK. It’s likely that the SDK will return the email asynchronously using a callback, meaning that we now have three levels of nested callbacks. If we keep adding complexity, this approach will result into what is known as callback hell.",B,MVP,M,,,,,,,,
151,Too many nested callbacks means the code is ugly and difficult to understand so painful to make changes or add new features.,B,GEN,,,,,,,,,
152,"Unit testing becomes challenging, if not impossible, because a lot of the logic lives within the Activities or Fragments that are arduous to unit test.",B,GEN,,x,x,,,,,,
153,"RxJava allows you to manage data via asynchronous streams and gives you many operators that you can apply to the stream in order to transform, filter or combine the data.",G,GEN,,,,,,,,,
155,RxJava Observables and operators remove the need for having nested callbacks.,G,GEN,,,,,,,,,
154,"The DataManager is the brain of the architecture. It extensively uses RxJava operators to combine, filter and transform data retrieved from helper classes. The aim of the DataManager is to reduce the amount of work that Activities and Fragments have to do by providing data that is ready to display and won’t usually need any transformation.",G,MVP,M,,,,,,,,
171,"Don’t Reinvent the Wheel. Initially, I had a bad idea of not using opensource libraries. Whatever I needed, I just wanted to make it myself. It’s was seriously a terrible idea. Focus more on the core business logic of your app. If you want to make network calls in your app, you don’t need to make a Retrofit yourself.",M,GEN,,,,,,,,,
156,"The DataManager takes over responsibilities that were previously part of the view layer. Hence, it makes Activities and Fragments more lightweight.",G,MVP,M,,,,,,,,
157,Moving code from Activities and Fragments to the DataManager and helpers means that writing unit tests becomes easier.,G,MVP,"M,V",x,x,,,,,,
158,"Clear separation of responsibilities and having the DataManager as the only point of interaction with the data layer, makes this architecture testfriendly. Helper classes or the DataManager can be easily mocked.",G,MVP,"M,V",,,,,,,,
159,For large and very complex projects the DataManager can become too bloated and difficult to maintain.,B,MVP,M,,,,,,,,
160,"Although view layer components such as Activities and Fragments became more lightweight, they still have to handle a considerable amount of logic around managing RxJava subscriptions, analysing errors, etc.",M,MVP,"P,V",x,x,,,,,,
161,"Activities and Fragments become very lightweight. Their only responsibilities are to set up/update the UI and handle user events. Therefore, they become easier to maintain.",G,MVP,"P,V",x,x,,,,,,
162,"We can now easily write unit tests for the presenters by mocking the view layer. Before, this code was part of the view layer so we couldn’t unit test it. The whole architecture becomes very testfriendly.",G,MVP,P,x,x,,,,,,
163,"If the data manager is becoming bloated, we can mitigate this problem by moving some code to the presenters.",M,MVP,"M,P",,,,,,,,
164,Having a single data manager can still be an issue when the codebase becomes very large and complex. We haven’t reached the point where this is a real problem but we are aware that it could happen.,B,MVP,M,,,,,,,,
165,"In MVP (or at least, in our vision of MVP) it is only the view that holds the current state of itself. Think about a screen that shows a “Loading….” spinner: the Presenter sets such spinner to visible, and once the requested data is loaded the spinner is hidden. But what happens if, in the meantime, the presenter wants to know if the spinner is visible? It can either privately keep this information or query the view for it. Now, what if the screen has more and more features? Is the presenter going to keep the current “state” of every single button, view, list along with the business logic of the app? Well, if yes: the complexity to keep synchronised what the view is showing and what the presenter knows about the view will easily explode. Because an Android View is a very transient object, that could be destroyed at any given moment, and because the View is the state, it is hard to keep track and recreate exactly the last screen visualized to the user.",B,MVP,"P,V",,,,,,,,
166,"The Reducer [custom component] is what applies updates to the State. It is no more than a pure function which takes the old State, an Action and returns the new State. It is the job of the Reducer to turn Actions into State. For example if we receive a ‘loading started’ action we would flip the loading flag in the State. Because the Reducer is a pure function, only acting on its inputs, it makes it really easy to test. Furthermore, because the reducer is the only place that is mutating state, if you see unexpected state, you know where to fix it. This means much less time hunting for the source of bugs.",G,CUSTOM,"V,C",,,,,,,,
167,We feel that this approach allows us to better manage the state within our app. Because all state changes go through the reducer we can easily test and debug. All changes are represented as actions and flow through a single point into the store.,G,CUSTOM,C,,,,,,,,
168,MVVM can not be justified for small projects.,B,MVVM,"M,VM,M",,,,,,,,
169,"If the data binding logic is too complex, application debug will be a little harder.",B,MVVM,"M,VM,M",,,,,,,,
170,"Do not make reference to a database or an API directly in the ViewModel. Instead, create Repository for each VM — thus the code will be cleaner and less bulky.",M,MVVM,"M,VM",x,x,,,,,,
172,"There are lots and lots of opensource libraries available in Github for you to use for FREE. But don’t get too excited and start using libraries blindly. Check the number of stars that particular library has, the more the better. Check if the author of that library have also created some other popular libraries as well. Check the issues (both open and closed), which can give you a better idea of how robust and stable the library is in production. If you can afford the time, you should dive into the code of that library and check yourself if its really worth it.",M,GEN,,,,,,,,,
173,"For God’s Sake, Maintain Proper Coding Standards. If you compare coding with writing, then coding standards is like your handwriting. As you would be reading more of others code, other people will also be reading a lot of your code and you don’t want to scare the shit out of them, do you? And if you are working in an organization and collaborating with other developers heavily, do take special care about it. Write short, clean and readable code that YOU and people reading your code would enjoy thoroughly. Your code should read like a story.",M,GEN,,,,,,,,,
174,"Never ever, ever make the mistake of releasing your app on the Play Store without using ProGuard. ProGuard not only minifies your code, but it obfuscates your code making it harder for reverseengineers to understand, replicate and manipulate it.",B,GEN,,,,,,,,,
191,benefits we get out of this RxJava: Decoupling between Observables and Subscribers: makes maintainability and testing easier.,G,GEN,,,,,,,,,
175,"One of the biggest problems of Android is that views (Activities, Fragments,…) aren’t easy to test because of the framework complexity. To solve this problem, you should implement the Passive View pattern. The implementation of this pattern reduces the behavior of the view to the absolute minimum by using a controller, in our case, the presenter. For example, if you have a username/password form and a “submit” button, you don’t write the validation logic inside the view but inside the presenter. Your view should just collect the username and password and send them to the presenter.",M,MVP,"V,P",x,x,,,,,,
176,"In order to make the previous principle really effective (improving testability), make sure that presenter doesn’t depend on Android classes. Write the presenter using just Java dependencies for two reasons: firstly you are abstracting presenter from implementation details (Android framework) and consequently, you can write noninstrumented tests for the presenter (even without Robolectric), running tests faster on your local JVM and without an emulator.",G,MVP,P,,,,,,,,
177,"You may need the context to access shared preferences or resources, for example. But you shouldn’t do that in the presenter: you should access to resources in the view and to preferences in the model. By the way, the dependency inversion principle helps a lot in cases like this, when you need to decouple an object.",M,MVP,"M,V,P",,,,,,,,
178,"When you are going to write a new feature, it is a good practice to write a contract at first step. The contract describes the communication between view and presenter, it helps you to design in a cleaner way the interaction.",G,MVP,"V,P",,,,,,,,
179,"The View contract: Like I said before, the view is implemented by an Activity (or a Fragment). The presenter must depend on the View interface and not directly on the Activity.",G,MVP,"V,P",x,x,,,,,,
180,"During the “contract design” phase, you must decide for each user event, what is the corresponding action and who the logic should belong to.",G,MVP,"V,P",,,,,,,,
181,"Do not create Activitylifecyclestyle callbacks in the Presenter interface. In this way, the presenter would be coupled in particular with the Activity lifecycle. The presenter shouldn’t have a so complex lifecycle.",B,MVP,P,x,,,,,,,
182,Presenter has a 1to1 relation with the view. The presenter doesn’t make sense without a view. It comes with the view and goes when the view is destroyed. It manages one view at a time.,G,MVP,"V,P",,,,,,,,
183,"Do not save the state inside the presenter. I mean using a Bundle. I’m not saying that the presenter should be stateless because I’d be lying. In the use case I described before, for instance, the presenter should at least have the page number/offset somewhere.",B,MVP,P,,,,,,,,
184,"No. Do not retain the presenter. I don’t like this solution mainly because I think that presenter is not something we should persist, it is not a data class, to be clear.",B,MVP,P,,,,,,,,
185,"Provide a cache for the Model to restore the View state. In my opinion, solving the “restore state” problem requires adapting a bit the app architecture. A great solution in line with this thoughts was proposed in this article. Basically, the author suggests caching network results using an interface like a Repository or anything with the aim to manage data, scoped to the application and not to the Activity (so that it can survive to orientation changes).",G,MVP,"M,V",,,,,,,,
186,"The purpose is the separation of concerns by keeping the business rules not knowing anything at all about the outside world, thus, they can can be tested without any dependency to any external element. To achieve this, my proposal is about breaking up the project into 3 different layers, in which each one has its own purpose and works separately from the others. It is worth mentioning that each layer uses its own data model so this independence can be reached (you will see in code that a data mapper is needed in order to accomplish data transformation, a price to be paid if you do not want to cross the use of your models over the entire application).",G,CLEAN,C,,,,,,,,
187,"Presentation layer: Presenters in this layer are composed with interactors (use cases) that perform the job in a new thread outside the main android UI thread, and come back using a callback with the data that will be rendered in the view.",G,CLEAN,C,,,,,,,,
188,"Fragments and activities are only views, there is no logic inside them other than UI logic, and this is where all the rendering stuff takes place.",G,CLEAN,C,x,x,,,,,,
189,"Domain layer: all the logic happens in this layer. Regarding the android project, you will see all the interactors (use cases) implementations here as well. This layer is a pure java module without any android dependencies. All the external components use interfaces when connecting to the business objects.",G,CLEAN,C,,,,,,,,
190,"Data layer: Use a Repository pattern. The idea behind all this is that the origin of the data is transparent to the client, which does not care if the data is coming from memory, disk or the cloud, the only truth is that the information will arrive and will be gotten.",G,CLEAN,C,,,,,,,,
192,"Simplified asynchronous tasks: java threads and futures are complex to manipulate and synchronize if more than one single level of asynchronous execution is required, so by using schedulers we can jump between background and main thread in an easy way (with no extra effort), especially when we need to update the UI. We also avoid what we call a “callback hell”, which makes our code unreadable and hard to follow up.",M,GEN,,,,,,,,,
194,"Use Dagger as (i) components become reusable (since dependencies can be injected and configured externally), (ii) when injecting abstractions as collaborators, we can just change the implementation of any object without having to make a lot of changes in our codebase, (iii) Dependencies can be injected into a component: it is possible to inject mock implementations of these dependencies which makes testing easier.",G,GEN,,,,,,,,,
193,"Data transformation/composition: we can combine multiple Observables<T> without affecting the client, which makes our solution more scalable.",G,CLEAN,C,,,,,,,,
195,I consider code/package organization one of the key factors of a good architecture: package structure is the very first thing encountered by a programmer when browsing source code. Everything flows from it. Everything depends on it. Either package by layer of functionality.,G,GEN,,,,,,,,,
196,Organize your build logic (Gradle) and group stuff by functionality in separate gradle build files.,G,GEN,,,,,,,,,
197,Create maps of dependencies.,G,GEN,,,,,,,,,
199,Minimize framework (android) dependencies in your project as much as you can.,G,GEN,,,,,,,,,
202,"In Android screen orientation change is a challenging problem. The simplest way to deal with that is to ignore it. Just reload everything on each screen orientation change. This is a completely valid solution. Most of the time your app works offline too so that data comes from a local database or another local cache. Therefore, loading data is superfast after screen orientation changes. However, I personally dislike seeing a loading indicator [...]",B,GEN,,x,x,,,,,,
210,Decoupled code makes it easy to focus your attention on specific issues without a lot of bloatware getting in the way,G,GEN,,,,,,,,,
200,"A Presenter (or ViewModel) has arbitrarily many inputs (the View triggers an action handled by Presenter) which is ok, but a Presenter also has many outputs (or output channels like view.showLoading() or view.showError() in MVP or ViewModel is offering multiple Observables) which eventually leads to conflicting states of View, Presenter and business logic especially when working with multiple threads.",B,MVVM,P,,,,,,,,
201,What if we only have one single source of truth for state passed from bottom (business logic) to the top (the View). [It would be a very good thing],G,MVVM,"M,V",,,,,,,,
212,"[Through dagger] we can manage the scope of our instances created, which is something really cool and from my point of view, Any object or collaborator in your app should not know anything about instances creation and lifecycle and this should be managed by our dependency injection framework.",G,GEN,,x,x,x,x,x,,,
203,"We only need a Model class that is representing the whole state. Then it’s easy to save this Model into a bundle and to restore it afterwards. However, I personally think that most of the time it is better to not save the state but rather reload the whole screen just like we are doing on first app start.",G,CUSTOM,C,,,,,,,,
204,"there is only one single source of truth: the business logic. We let click events “sink down” to the business logic. The business logic knows the current Model (i.e. has a private field with the current Model) and will create a new Model with the incremented / decremented value according to the old Model. By doing so we have established a unidirectional data flow with the business logic as single source of truth which creates immutable Model instances. But this seems so over engineered for just a simple counter, doesn’t it? Yes, a counter is just a simple app. Most apps start as a simple app but then the complexity grows fast. A unidirectional data flow and an immutable model is necessary from my point of view even for simple apps to ensure they stay simple (from developers point of view) when complexity grows.",G,CUSTOM,C,,,,,,,,
205,The business logic layer does not contain any framework specific code and you should be able to run it without an emulator. This layer does not contain any framework specific code and you should be able to run it without an emulator.,G,CLEAN,B,,,,,,,,
206,"Each layer, above the core layer, is also responsible for converting models to lower layer models before the lower layer can use them. An inner layer can not have a reference to model class that belongs to the outer layer. However, the outer layer can use and reference models from the inner layer.",G,CLEAN,"B,I,F",,,,,,,,
207,"Your business logic models might not be appropriate for showing them to the user directly. Perhaps you need to show a combination of multiple business logic models at once. Therefore, I suggest you create a ViewModel class that makes it easier for you to display it to the UI. Then, you use a converter class in the outer layer to convert your business models to the appropriate ViewModel.",M,CLEAN,B,,,,,,,,
208,Everything that is not strictly view related should go into the Presenter class.,G,CLEAN,I,,,,,,,,
209,Writing the storage layer: This is where our repository gets implemented. All the database specific code should come here.,G,MVP,M,,,,,,,,
213,"The @PerActivity is a custom scoping annotation to permit objects whose lifetime should conform to the life of the activity to be memorized in the correct component. I really encourage to do this as a good practice, since we get these advantages: The ability to inject objects where and activity is required to be constructed. The use of singletons on a peractivity basis. The global object graph is kept clear of things that can be used only in activities.",G,GEN,,x,,,,,,,
211,In conclusion I feel that the simplest way to work with data is to have an Activity/Fragment/View which owns a Presenter. That Presenter can request data from an app scoped Store which can either fetch new data or return cached data.,G,MVP,"P,M",,,,,,,,
215,"How does a “ChildPresenter” communicate with its “ParentPresenter”? From my point of view such ParentChild relations are a code smell, because they introduce a direct coupling between both Parent and Child, which leads to code that is hard to read, hard to maintain, where changing requirement affects a lot of components (hence it’s a virtually impossible task in large systems) and last but not least introduces shared state that is hard to predict and even harder to reproduce and debug.",B,GEN,,,,,,,,,
218,"We realised there are several ways to use RxJava. The most straightforward one is for asynchronous calls, where you subscribe to an Observable that will eventually emit onNext or onError and complete afterwards, a typical example of this are the observables from retrofit calls. It’s like a callback on steroids, you can control the threads where things are executed very easily and there’s a bunch of very powerful operators that allow you to combine/transform the result.",G,GEN,,,,,,,,,
214,The LiveData class has a few guarantees that simplify the way we observe it: - All state changes are dispatched on the main thread. This means we can immediately access android views and update displayed data. - Changes are dispatched only when the observer is active: its Lifecycle is in a STARTED or RESUMED state. This means we won’t get any unnecessary updates when our activity is not visible. - New observer receives current value as soon as it becomes active. This means we will always have something to display as soon as our activity becomes visible. - When the observer is DESTROYED the LiveData removes it from the observer list. This means we don’t have to remember to “unsubscribe” because it will be done automatically. - The order of all these life cycle related events is carefully designed so we never get infamous fragment transaction exceptions.,G,CUSTOM,"M,V,P",x,,,,,,,
223,"The view entity should be designed to represent as close as possible the state of one specific view. Some time ago I wrote a blog post about how to design this view entities safely, things that need to be taken into account when dealing with RxJava + MVVM.",G,GEN,,x,,,,,,,
216,"So far so good, but somehow the information must flow from Presenter A to Presenter B: How does a Presenter communicate with another Presenter? They don’t! What would a Presenter have to tell another Presenter? Event X has happened? Presenters don’t have to talk to each other, they just observe the same Model (or the same part of the business logic to be precise). In contrast to MVP or MVVM in MVI we are forced (in a positive way) that business logic drives the state of a certain component.",G,CUSTOM,"V,P",,,,,,,,
217,"With a unidirectional data flow and a Model that represents State a lot of state related things are much simpler to implement compared to other patterns. However, usually I don’t persist state into a bundle in my apps for two reasons: First, Bundle has a size limit, so you can’t put arbitrary large state into a bundle (alternatively you could save state into a file or an object store like Realm). Second, we only have discussed how to serialize and deserialize state but that is not necessarily the same as restoring state.",G,CUSTOM,C,,,,,,,,
229,"[...] Onion Architecture, Hexagonal Architecture (also known as Ports and Adapters) and the popular Clean Architecture, among other layered architectures. Though these approximations have their own fancy names and could seem completely different, they share a lot in common. In fact, its main intent is the same: Achieve a highlevel separation of concerns by layering.",G,GEN,,,,,,,,,
219,The plan is to put in the store the objects that are going to be consumed by the layers on top. This layer will build use cases out of these objects so let’s make sure the data we store is in good conditions. [Reactive Clean Architecture],G,"MVVM,CLEAN",M,,,,,,,,
220,"Most of apps get the data from an API, which has a contract that describes what data and what format this API should serve the data. In 99% of the cases this contract is satisfied but… what happens when it is not? This can be achieved by defining two POJOs, one that represents the object that comes from the external source, we refer to this as the “raw” entity, and another one that is the mapped object, the one that has been checked and is safe to store, we call this one the “safe” entity. By mapping the raw entity to the safe entity before storing it we are creating a first line of defence.",G,CUSTOM,C,,,,,,,,
221,"This layer [domain] sits on top of the data and is responsible for coordinating the actions to the repository. It can also perform some mappings to prepare the objects coming from the data layer, that way the presentation layer can consume them easily. The domain [layer] is 100% Java only, meaning that there are no Android framework related objects here. [Reactive Clean Architecture]",G,"MVVM,CLEAN",,,,,,,,,
222,"This [presentation layer] is the last layer, responsible for building the objects the views are going to consume and processing the actions performed in this views. This is also the layer where the Android Architecture Components are used, more specifically, the LiveData and the ViewModel.",G,"MVVM,CLEAN",,,,,,,,,
230,[General on styles] There are a lot of scenarios where we aren’t gonna need that level of adaptability. Especially in mobile applications in which the domain logic is really close to the view. Prematurely creating that kind of indirection and isolation is usually a waste of time and it may be a bit overkill.,B,GEN,,,,,,,,,
224,"In MVVM pattern, the ViewModel is the component that interacts with the views, this leads to often have big view models, especially when the screen is complex. We tried to simplify our view models delegating some responsibilities to other components: - Mappers and transformers: They transform the objects coming from the domain layer to view entities. - Providers: Sometimes we need something from the framework to build our view entity, for instance, we might need a specific string. We create the StringProvider to abstract the access to this resource. - Utilities: There is not much to say here, these are the classical utility classes that contain helper functions.",M,"MVVM,CLEAN","VM, C",x,x,,,x,,,
225,"[On MVVM] The View Model should not do any of the things the components above can do. The View Model should coordinate the process of creating view entities and put all the pieces together. After doing this we noticed several benefits: the most obvious one was that the view models have a much smaller size, everything was easier to test since each class has a more specific and narrow responsibility, it is more clear what are the inputs/outputs and what is expected from each class. Of course this also makes the whole presentation layer more understandable and readable.",G,"MVVM,CLEAN",VM,,,,,,,,
226,"[On MVVM] The importance of a well designed view entity. One common mistake is to pass the view an object that hasn’t been designed for it, usually because we don’t want to create another object that is specific for the view, so we rather just pass the one that comes from our data or domain layer. This should be avoided because it means that the view needs to do some final transformations to be able to consume it, leaving code that contains untested logic. In our experience, the most critical step working in the presentation layer is the design of the view entities. Creating these POJOs is in a way the main goal of the presentation layer and defines how readable, understandable and testable the whole layer is. [Nice quote on MVVM] Take your time designing the view entities. You don’t want to deal with a poorly designed one and it is painful to change them when the implementation of the presentation layer is advanced.",B,"MVVM,CLEAN","VM,V",,,,,,,,
227,"Expose states and not events: expose one stream per view that emits states instead of events. Both the position and the data set should be wrapped up together so the ViewPager never receives one without the other. This is true for any view with intradependent state. You would never expose two separate streams for a TextView, one that sets the text and another one that emits the position of the letter that should be highlighted in bold, but for some reason it’s much easier to make this mistake with a ViewPager or lists. [MVVM+RxJava]",M,MVVM,V,x,x,,,,,,
228,"[MVVM+RxJava] Everything goes through the view model: the view model transforms the data into something that is easy to use in the Views or any other consumer, this means the view should know about the changes always after the view model. So basically, it doesn’t matter how trivial or easy an operation is, everything should go through the view model, this way other stuff that is based on the view model’s state can happen reliably. The view should know about the changes always after the view model.",G,MVVM,"M,VM,V",,,,,,,,
232,"It’s all about decoupling your business logic from the outside world (meaning frameworks, implementation details, etc.) and ending up with the maintainable, testable and with low technical debt application",G,GEN,,,,,,,,,
235,"As Robert Martin, aka Uncle Bob, says, “Your architecture should scream the purpose of the app.” More technically said, business logic should be clearly separated and independent of the framework.",G,GEN,,,,,,,,,
231,"[General on onion like ark] Source code dependencies can only flow from outside, in. Nothing in an inner layer can know anything at all about something in an outer layer.",G,CLEAN,,,,,,,,,
236,"Satisfy a multitude of stakeholders: all interactions are separated in the classes/modules/components/whatever whose job is interactions, and that particular developer works only on those components while working on the UX part of the app.",G,GEN,,,,,,,,,
233,"[Hexagonal ark] The main objective of this architecture is to separate concerns and have the business logic isolated, through the implementation of Ports and Adapters",G,CLEAN,,,,,,,,,
234,"This [the hexagonal module] is the most important part of our application, where the core logic and the business rules live. It’s what makes our app different from others. Because it’s completely Androidfree, we defined it as a Java only module but you could use another language like Scala or Kotlin if you want.",G,CUSTOM,C,,,,,,,,
237,"Encourage separation of concerns. What I have said before is an example of separation of concerns. We encourage that particular approach because it maps nicely to the organization of teams and project phases, but your architecture should also encourage separation of concerns generally. Separation of concerns, or the single responsibility principle, says that every component should have only one reason to change.",G,GEN,,,,,,,,,
238,"Run away from the real world (Android, DB, Internet…). We have already said that we want to scream what the app really does; that’s it. We want to emphasize business logic and leave framework details under the hood. This point should be even stronger: we would like to not only hide framework details but all the details related to the outside world.",G,GEN,,,,,,,,,
239,"Enable your components to be testable. You should unit test your app as much as possible and your architecture should allow you to do it. If you can’t unit test everything, you should at least cover your business logic with tests. Separation from the real world goes nicely with this. It’s easier to test your business logic if it is clearly separated from the rest of the app.",G,GEN,,,,,,,,,
240,"God Activity: We have an activity that touches databases, goes to the Internet, does parsing, spawns threads, and renders data. So, all the stakeholders are looking at the single class, none of the concerns is separated, it’s not testable, and business logic is mixed with the Android stuff.",B,GEN,,x,,,,,,,
252,"[On clean ark] Although it’s a bit hidden, the same data flow inversion principle still holds, because without RxJava presenters were implementing the callback, and with RxJava subscribers are also contained in the outer layer – somewhere in the presenter.",G,"GEN,CLEAN",F,,,,,,,,
254,Activities were often bloated with multiple responsibilities. There was a lot of code duplication custom views and custom logic.,B,GEN,,x,,,,,,,
241,"[MVP] The elephant in the room here is the presenter. It’s a god object. It deals with the models, it sends the data to the view, it holds the business logic (business logic are those gears :) ), and it goes to the database and Internet, fetches sensor data, etc. So yeah, better, but it could get way more better.",B,MVP,P,,,,,,,,
242,"[MVP, To solve god presenter] introduce some manager. You don’t have to name it “manager.” There are lots of names for these kind of classes: utils, helpers, fooBarBuzzator, etc. So, we introduced managers. Business logic is contained in the manager classes. Stakeholders know where to look at, concerns are sort of separated",G,"MVP,CUSTOM","P,C",,,,,,,,
243,[on MVP+managers] managers tend to be huge beasts and very quickly become hard to maintain,B,"MVP,CUSTOM","P,C",,,,,,,,
244,"[On clean code ark] domain module. If you want an extra challenge with a reward of eternal glory and a totally clean design, you can make that module a pure Java module. It will prevent you from taking shortcuts and putting something related to the Android here.",,CLEAN,B,,,,,,,,
245,"[On clean code ark] The device module should have everything related to Android that’s not data persistence and UI. The data module should hold everything related to data persistence, as we’ve already said. You cannot make those two into Java modules because they need access to various Android stuff. You can make them into Android library. [...] Data and Device modules contain all of the implementation details that business logic does not care about. It only cares about the contracts, allowing you to easily test it and swap out implementations without touching the business logic. [...] Each data source, both network, and local storage, will have its own models to work with.",G,CLEAN,I,,,,,,,,
246,"[On clean code ark] we group everything related to the UI (including presenters) into the UI module. You can explicitly name it UI but because of all the Android stuff here, we leave it named “app,” just as Android Studio named it during the creation of the project.",G,CLEAN,F,,,,,,,,
247,[On clean ark] We have pushed Android and the realworld stuff as far out on the outskirts as we can. Business logic doesn’t touch the Android directly anymore.,G,CLEAN,,,,,,,,,
248,[On clean ark] We have nicely separated classes that are easy to test. Classes touching the world can be tested using Android test cases; the one not touching it can be tested using JUnit. Someone malevolent would maybe call that class explosion. I call it testable. :),G,CLEAN,,,,,,,,,
249,"[On clean ark] The data module should hold everything related to data persistence and manipulation. Here we will find DAOs, ORMs, SharedPreferences, network related stuff like Retrofit services and similar.",G,CLEAN,E,,,,,,,,
250,"[On clean ark] The device module should have everything related to Android that’s not data persistence and UI. In example, wrapper classes for ConnectivityManager, NotificationManager and misc sensors. We will make both Data and Device modules android modules, as they must know about Android and cannot be pure java.",G,CLEAN,I,,,,,,,,
251,"[On clean ark] The easiest part, app module (UI module). This module is already created for you by the Android studio when you create a project. Here you can place all the classes related to the Android UI such as presenters, controllers, view models, adapters and views.",G,CLEAN,F,,,,,,,,
256,"For example, you should be able to look at a package structure and understand how it’s organized. I often think about this from the perspective of writing open source code: would my code be apparent to I don’t know, and who isn’t on my team?",G,GEN,,,,,,,,,
253,"[On clean ark] It is a good practice for every layer to have its own model that it works with, so your concrete details, such as views, do not depend on the specific details of your lower layer implementations. This way, you won’t have to break unrelated code if you, for example, decide to change from one ORM to another. To make that possible, it is necessary to use object mappers in each layer.",G,CLEAN,,,,,,,,,
269,"Use as much as possible the Android components, e.g. someone used a bloatware custom dock instead of using stock Android library.",G,GEN,,,,,,,,,
255,"[MVP + Managers] But we had this data manager class, which was already becoming bloated with multiple responsibilities. It was accessing the API, accessing the cache. It felt a bit like oh we got this data operation, let’s stick it in that data manager class. It’s messy. There was a data manager class with multiple responsibilities it was accessing the API and accessing the cache alongside preference helper classes. Despite splitting these out into a composer and user data manager, it was still bloated and unorganized. In the instance of the data manager, if we wanted to take the app offline in the future, how would we be able to accomplish that based on its current state?",B,MVP,M,,,,,,,,
197-198,"Create maps of dependencies. This is very useful if you want to reuse the same artifact version across different modules in your project, or maybe the other way around, where you have to apply different dependency versions to different modules. Another plus one, is that you also control the dependencies in one place and, for instance, bumping an artifact version is pretty straightforward.",G,GEN,,,,,,,,,
257,"Layer Models: Enterprise Business Rules: The first layer is the enterprise business rules, the core business rules of our application. For example, Twitter’s rules might be a profile or a tweet. Unless the needs of your business change, you should never need to touch these once they have been created. These can also be created before you write your UI.",G,CLEAN,E,,,,,,,,
258,"[MVVM] The consumer of the data should know about the producer, but the producer — the ViewModel — doesn’t know, and doesn’t care, who consumes the data.",G,MVVM,"M,VM",,,,,,,,
259,"[MVVM] Our strong emphasis on the single responsibility principle leads to creating a DataModel for every feature in the app. For example, we have an ArticleDataModel that composes its output from the API service and database layer. This DataModel handles the business logic ensuring that the latest news from the database is retrieved, by applying an age filter.",G,MVVM,M,,,,,,,,
260,"[MVVM] The ViewModel should expose states for the View, rather than just events.",G,MVVM,VM,,,,,,,,
261,[MVVM] We should make sure that every action of the user goes through the ViewModel and that any possible logic of the View is moved in the ViewModel.,G,MVVM,"V,VM",x,x,,,,,,
262,"[MVVM] DataModel: The use of inversion of control pattern, heavily applied in our code, and the lack of any Android classes, facilitate the implementation of unit tests of the DataModel.",G,MVVM,M,,,,,,,,
263,[MVVM] we are creating model objects to hold the state of the data. This also allows a higher degree of testability and control of the data that is emitted by the ViewModel.,G,MVVM,M,,,,,,,,
264,"[MVP] The ModelViewPresenter pattern brings with it a very good separation of concerns. While this is for sure a pro, when developing a small app or a prototype, this can seem like an overhead. To decrease the number of interfaces used, some developers remove the Contract interface class, and the interface for the Presenter.",G,MVP,"V,P",,,,,,,,
265,"[MVP] One of the pitfalls of MVP appears when moving the UI logic to the Presenter: this becomes now an allknowing class, with thousands of lines of code. To solve this, split the code even more and remember to create classes that have only one responsibility and are unit testable.",M,MVP,P,,,,,,,,
266,"[MVCMVP] The ModelViewController pattern has two main disadvantages: firstly, the View has a reference to both the Controller and the Model; and secondly, it does not limit the handling of UI logic to a single class, this responsibility being shared between the Controller and the View or the Model. The ModelViewPresenter pattern solves both of these issues by breaking the connection that the View has with the Model and creating only one class that handles everything related to the presentation of the View — the Presenter: a single class that is easy to unit test.",M,MVP,"M,V,P",,,,,,,,
267,"[MVP] Presenter: In the implementation of the constructor, the Presenter will call the setPresenter method of the View. This can be simplified when using a dependency injection framework that allows the injection of the Presenters in the corresponding views, reducing the coupling of the classes.",G,MVP,P,,,,,,,,
268,"[MVP] To make the Presenter unit testable with JUnit, the View is abstracted and an interface for it used. The relationship between the Presenter and its corresponding View is defined in a Contract interface class, making the code more readable and the connection between the two easier to understand.",G,MVP,"V,P",,,,,,,,